<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>PL/Rust Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="plrust.html">What is PL/Rust?</a></li><li class="chapter-item expanded affix "><li class="part-title">Installation</li><li class="chapter-item expanded "><a href="install-prerequisites.html"><strong aria-hidden="true">1.</strong> Install Prerequisites</a></li><li class="chapter-item expanded "><a href="install-plrust.html"><strong aria-hidden="true">2.</strong> Install PL/Rust</a></li><li class="chapter-item expanded "><a href="update-plrust.html"><strong aria-hidden="true">3.</strong> Update PL/Rust</a></li><li class="chapter-item expanded "><a href="install-plrust-on-debian-ubuntu.html"><strong aria-hidden="true">4.</strong> Install PL/Rust on Debian/Ubuntu</a></li><li class="chapter-item expanded "><a href="try-plrust-with-docker.html"><strong aria-hidden="true">5.</strong> Try PL/Rust with Docker</a></li><li class="chapter-item expanded affix "><li class="part-title">PL/Rust Usage</li><li class="chapter-item expanded "><a href="use-plrust.html"><strong aria-hidden="true">6.</strong> PL/Rust Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="functions/anatomy.html"><strong aria-hidden="true">6.1.</strong> Function Anatomy</a></li><li class="chapter-item expanded "><a href="functions/arguments.html"><strong aria-hidden="true">6.2.</strong> Arguments</a></li><li class="chapter-item expanded "><a href="functions/return-type.html"><strong aria-hidden="true">6.3.</strong> Return Type</a></li><li class="chapter-item expanded "><a href="functions/set-returning-functions.html"><strong aria-hidden="true">6.4.</strong> Set Returning Functions</a></li></ol></li><li class="chapter-item expanded "><a href="data-types.html"><strong aria-hidden="true">7.</strong> Data types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="data-types/no-unsigned-types.html"><strong aria-hidden="true">7.1.</strong> No Unsigned Types</a></li><li class="chapter-item expanded "><a href="data-types/arrays.html"><strong aria-hidden="true">7.2.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="data-types/udts.html"><strong aria-hidden="true">7.3.</strong> User Defined Types</a></li></ol></li><li class="chapter-item expanded "><a href="built-in-functions.html"><strong aria-hidden="true">8.</strong> Built-in functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="logging.html"><strong aria-hidden="true">8.1.</strong> Logging to PostgreSQL from PL/Rust</a></li><li class="chapter-item expanded "><a href="triggers.html"><strong aria-hidden="true">8.2.</strong> Triggers</a></li><li class="chapter-item expanded "><a href="spi.html"><strong aria-hidden="true">8.3.</strong> SPI</a></li><li class="chapter-item expanded "><a href="dynamic-function-calling.html"><strong aria-hidden="true">8.4.</strong> Dynamic Function Calling</a></li></ol></li><li class="chapter-item expanded "><a href="trusted-untrusted.html"><strong aria-hidden="true">9.</strong> Trusted and Untrusted PL/Rust</a></li><li class="chapter-item expanded "><a href="config-pg.html"><strong aria-hidden="true">10.</strong> PostgreSQL configuration</a></li><li class="chapter-item expanded affix "><li class="part-title">PL/Rust Under the Hood</li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">11.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="designing-for-trust.html"><strong aria-hidden="true">12.</strong> Designing for Trust</a></li><li class="chapter-item expanded "><a href="dependencies.html"><strong aria-hidden="true">13.</strong> External Dependencies</a></li><li class="chapter-item expanded "><a href="config-lints.html"><strong aria-hidden="true">14.</strong> Lints</a></li><li class="chapter-item expanded "><a href="config-env-var.html"><strong aria-hidden="true">15.</strong> Environment variables</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PL/Rust Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="what-is-plrust"><a class="header" href="#what-is-plrust">What is PL/Rust?</a></h1>
<blockquote>
<p>This documentation is under development.</p>
</blockquote>
<p>PL/Rust is a loadable procedural language that enables writing PostgreSQL
functions in the Rust programming language. These functions are compiled to
native machine code. Unlike other procedural languages, PL/Rust functions are
not interpreted.</p>
<p>The top advantages of PL/Rust include writing natively-compiled functions to achieve the absolute best performance,
access to Rust's large development ecosystem, and Rust's compile-time safety guarantees.</p>
<p>PL/Rust is Open Source and <a href="https://github.com/tcdi/plrust">actively developed on GitHub</a>.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<p>PL/Rust provides access to Postgres' Server Programming Interface (SPI) including dynamic queries, prepared
statements, and cursors. It also provides safe Rust types over most of Postgres built-in data types, including (but
not limited to), <code>TEXT</code>, <code>INT</code>, <code>BIGINT</code>, <code>NUMERIC</code>, <code>FLOAT</code>, <code>DOUBLE PRECISION</code>,
<code>DATE</code>, <code>TIME</code>, etc.</p>
<p>On <code>x86_64</code> and <code>aarch64</code> systems PL/Rust can be a "trusted" procedural language, assuming the proper compilation
requirements are met. On other systems, it is perfectly usable as an "untrusted" language but cannot provide the
same level of safety guarantees.</p>
<h2 id="example-plrust-function"><a class="header" href="#example-plrust-function">Example PL/Rust function</a></h2>
<p>The following example shows an example PL/Rust function to count the length of
an input string. See <a href="./use-plrust.html">PL/Rust Functions and Arguments</a>
for more examples.</p>
<pre><code class="language-sql">CREATE FUNCTION strlen(name TEXT)
    RETURNS int LANGUAGE plrust AS
$$
    Ok(Some(name.unwrap().len() as i32))
$$;
</code></pre>
<p>Using the function is just like any other PostgreSQL function.</p>
<pre><code class="language-sql">SELECT strlen('Hello, PL/Rust');
</code></pre>
<pre><code class="language-bash">┌────────┐
│ strlen │
╞════════╡
│     14 │
└────────┘
</code></pre>
<h2 id="built-on-pgrx"><a class="header" href="#built-on-pgrx">Built on pgrx</a></h2>
<p>PL/Rust itself is a <a href="https://github.com/tcdi/pgrx"><code>pgrx</code></a>-based Postgres extension.  Furthermore, each <code>LANGUAGE plrust</code> function are themselves mini-pgrx extensions. <code>pgrx</code>is a generalized framework for developing Postgres extensions with Rust.  Like this project, <code>pgrx</code>
is developed by <a href="https://www.tcdi.com">TCDI</a>.</p>
<p>The following sections discuss PL/Rusts safety guarantees, configuration settings, and installation instructions.</p>
<h1 id="general-safety-by-rust"><a class="header" href="#general-safety-by-rust">General Safety, by Rust</a></h1>
<p>Quoted from the "Rustonomicon":</p>
<blockquote>
<p>Safe Rust is the true Rust programming language. If all you do is write Safe Rust, you will never have to worry
about type-safety or memory-safety. You will never endure a dangling pointer, a use-after-free, or any other kind
of Undefined Behavior (a.k.a. UB).</p>
</blockquote>
<p>This is the universe in which PL/Rust functions live. If a PL/Rust function compiles it has these guarantees, by
the Rust compiler, that it won't "crash." This quality is important for natively-compiled code running in a
production database.</p>
<h2 id="what-about-unsafe"><a class="header" href="#what-about-unsafe">What about <code>unsafe</code>?</a></h2>
<p>PL/Rust uses the Rust compiler itself to wholesale <strong>disallow</strong> the use of <code>unsafe</code> in user functions. If
a <code>LANGUAGE plrust</code> function uses <code>unsafe</code> it won't compile.</p>
<p>Generally, what this means is that PL/Rust functions cannot call <code>unsafe fn</code>s, cannot call <code>extern "C"</code>s into
Postgres itself, and cannot dereference pointers.</p>
<p>This is accomplished using Rust's built-in <code>#![forbid(unsafe_code)]</code> lint.</p>
<p>3rd-party crate dependencies are allowed to use <code>unsafe</code>. We'll discuss this below.</p>
<h2 id="what-about-pgrx"><a class="header" href="#what-about-pgrx">What about <code>pgrx</code>?</a></h2>
<p>If <code>pgrx</code> is a "generalized framework for developing Postgres extensions with Rust", and if PL/Rust user functions
are themselves "mini-pgrx extensions", what prevents a <code>LANGUAGE plrust</code> function from using any part of <code>pgrx</code>?</p>
<p>The <a href="https://github.com/tcdi/plrust/tree/main/plrust-trusted-pgrx"><code>plrust-trusted-pgrx</code></a> crate does!
The <code>plrust-trusted-pgrx</code> crate is a tightly-controlled "re-export crate" on top of <code>pgrx</code> that exposes the bare minimum necessary for
PL/Rust user functions to compile along with the bare minimum, <strong>safe</strong> features of <code>pgrx</code>.</p>
<p>The crate is versioned independently to both <code>pgrx</code> and <code>plrust</code> and is published on <a href="https://crates.io/crates/plrust-trusted-pgrx">crates.io</a>.
By default, the version a plrust user function will use is that of the one set in the project repository when plrust itself
is compiled.  However, the <code>plrust.trusted_pgrx_version</code> GUC can be set to specify a specific version.</p>
<p>The intent is that <code>plrust-trusted-pgrx</code> can evolve independently of both <code>pgrx</code> and <code>plrust</code>.</p>
<p>There are a few "unsafe" parts of <code>pgrx</code> exposed through <code>plrust-trusted-pgrx</code>, but PL/Rust's ability to block <code>unsafe</code>
renders them useless by PL/Rust user functions.  <code>plrust-trusted-pgrx</code>'s docs are available on <a href="https://docs.rs/plrust-trusted-pgrx">docs.rs</a>.</p>
<h2 id="what-about-rust-compiler-bugs"><a class="header" href="#what-about-rust-compiler-bugs">What about Rust compiler bugs?</a></h2>
<p>PL/Rust uses its own <code>rustc</code> driver which enables it to apply custom lints to the user's <code>LANGUAGE plrust</code> function.
In general, these lints will fail compilation if the user's code uses certain code idioms or patterns which we know to
have "I-Unsound" issues.</p>
<p>PL/Rust contains a small set of <a href="config-lints.html">lints</a> to block what the developers have deemed the most egregious "I-Unsound" Rust bugs.</p>
<p>Should new Rust bugs be found, and detection lints are developed for PL/Rust, the lints can be applied to new user
function compilations along with ensuring that future function executions had those lints applied at compile time.</p>
<p>Note that this is done on a best-effort basis, and does <em>not</em> provide a strong level of security — it's not a sandbox,
and as such, it's likely that a skilled hostile attacker who is sufficiently motivated could find ways around it
(PostgreSQL itself is not a particularly hardened codebase, after all). You should ensure such actors cannot execute SQL
on your database, but to be clear: this is true regardless of whether or not PL/Rust is installed. Having said that, any
issues found with our implementation will be taken seriously, and should be
<a href="https://github.com/tcdi/plrust/blob/main/SECURITY.md">reported appropriately</a>.</p>
<h2 id="trusted-with-postgrestd-on-linux-x86_64aarch64"><a class="header" href="#trusted-with-postgrestd-on-linux-x86_64aarch64">Trusted with <code>postgrestd</code> on Linux x86_64/aarch64</a></h2>
<p>The "trusted" version of PL/Rust uses a unique fork of Rust's <code>std</code> entitled
<a href="https://github.com/tcdi/postgrestd"><code>postgrestd</code></a> when compiling <code>LANGUAGE plrust</code> user functions. <code>postgrestd</code> is
a specialized Rust compilation target which disallows access to the filesystem and the host operating system. The Install PL/Rust section outlines the steps required for
<a href="/install-plrust.html#trusted-install">trusted install</a> of PL/Rust.
Currently, <code>postgrestd</code> is only supported on Linux <code>x86_64</code> and <code>aarch64</code> platforms.</p>
<p>When <code>plrust</code> user functions are compiled and linked against <code>postgrestd</code>, they are prohibited from using the
filesystem, executing processes, and otherwise interacting with the host operating system.</p>
<p>In order for PL/Rust to use <code>postgrestd</code>, its Rust compilation targets must be installed on the Postgres server.
This happens via plrust's
<a href="https://github.com/tcdi/plrust/blob/main/plrust/build"><code>plrust/build</code></a> script, which clones <code>postgrestd</code>, compiles it, by
default, for both <code>x86_64</code> and <code>aarch64</code> architectures, and ultimately places a copy of the necessary libraries used by
Rust for <code>std</code> into the appropriate "sysroot", which is the location that <code>rustc</code> will look for building those
libraries.</p>
<h2 id="the-trusted-feature-flag"><a class="header" href="#the-trusted-feature-flag">The <code>trusted</code> Feature Flag</a></h2>
<p>PL/Rust has a feature flag simply named <code>trusted</code>. When compiled with the <code>trusted</code> feature flag PL/Rust will
<strong>always</strong> use the <code>postgrestd</code> targets when compiling user functions.
Again, this is only supported on <code>x86_64</code> and <code>aarch64</code> Linux systems.
<code>postgrestd</code> and the <code>trusted</code> feature flag are <strong>not</strong> supported on other platforms.
As such, PL/Rust cannot be considered fully trusted on those platforms.</p>
<p>If the <code>trusted</code> feature flag is not used when compiling PL/Rust, which is the default, then <code>postgrestd</code> is <strong>not</strong>
used when compiling user functions, and while they'll still benefit from Rust's general compile-time safety
checked, forced usage of the <code>plrust-trusted-pgrx</code> crate, and PL/Rust's <code>unsafe</code> blocking, they will be able to access the
filesystem and communicate with the host operating system, as the user running the connected Postgres backend
(typically, this is a user named <code>postgres</code>).</p>
<h1 id="plrust-is-also-a-cross-compiler"><a class="header" href="#plrust-is-also-a-cross-compiler">PL/Rust is also a Cross Compiler</a></h1>
<p>In this day and age of sophisticated and flexible Postgres replication, along with cloud providers offering
Postgres on, and replication to, disparate CPU architectures, it's important that plrust, since it stores the user
function binary bytes in a database table, support running that function on a replicated Postgres server of a
different CPU architecture.</p>
<p><em>cross compilation has entered the chat</em></p>
<p>By default, PL/Rust will not perform cross compilation. It must be installed
and enabled through configuration.</p>
<p>Configuring a <em>host</em> to properly cross compile is a thing that can take minimal effort to individual feats of
heroic effort. Reading the (still in-progress) <a href="https://github.com/tcdi/pgrx/blob/master/CROSS_COMPILE.md">pgrx cross compile guide</a>
can help. Generally speaking, it's not too awful to setup on Debian-based Linux systems, such as Ubuntu. Basically,
you install the "cross compilation toolchain" <code>apt</code> package for the <em>other</em> platform.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-plrust-prerequisites"><a class="header" href="#install-plrust-prerequisites">Install PL/Rust Prerequisites</a></h1>
<p>These instructions explain how to install PL/Rust on a typical OS PostgreSQL
installation installed using the OS' package manager. These instructions
include steps for <a href="trusted-untrusted.html">trusted and untrusted</a>
<code>plrust</code> and are tested using Ubuntu 22.04 and PostgreSQL 15.
PostgreSQL 15 for this document is installed using <code>apt</code> using
the <code>pgdg</code> repository.
See the <a href="https://wiki.postgresql.org/wiki/Apt">PostgreSQL apt wiki page</a>
for instructions.</p>
<p>Steps to install PL/Rust:</p>
<ul>
<li>Prerequisites</li>
<li>Install Rust</li>
<li>Install pgrx</li>
<li>Install PL/Rust</li>
<li>Create amazing things!</li>
</ul>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>PL/Rust requires PostgreSQL and all prerequisites outlined for
<a href="https://github.com/tcdi/pgrx#system-requirements">pgrx</a>
are installed.</p>
<p>PL/Rust also requires that any databases in which it's created is <code>UTF8</code>.  Postgres' default encoding is determined
by the locale of the environment when <code>initdb</code> is first run.  Depending on your operating system configuration, this may
not resolve to <code>UTF8</code>.</p>
<p><a href="https://wiki.postgresql.org/wiki/Compile_and_Install_from_source_code">Building PL/Rust from source</a> requires
installing <code>cargo-pgrx</code> which requires a development toolchain capable of building Postgres itself.</p>
<h3 id="permissions"><a class="header" href="#permissions">Permissions</a></h3>
<p>Installing PL/Rust with these instructions installs <code>rustc</code>, <code>pgrx</code>,
and <code>plrust</code> as the Linux <code>postgres</code> user.  The <code>postgres</code> user
is created during the standard PostgreSQL installation via <code>apt</code>.
For <code>pgrx</code> to successfully install <code>plrust</code>, the <code>postgres</code>
user needs ownership of the <code>extension</code> and <code>lib</code> directories.
The standard Ubuntu locations are indicated below.</p>
<pre><code class="language-bash">sudo chown postgres -R /usr/share/postgresql/15/extension/
sudo chown postgres -R /usr/lib/postgresql/15/lib/
</code></pre>
<p>These permissions are later reset back to being owned by <code>root</code>
in the <a href="install-plrust.html#reset-permissions">Reset Permissions</a> section.</p>
<h2 id="install-rustc"><a class="header" href="#install-rustc">Install <code>rustc</code></a></h2>
<p>Installing PL/Rust requires that the <code>rustc</code> compiler is available
to the user installing it.
Switch to the <code>postgres</code> Linux user and change into its home directory.</p>
<pre><code class="language-bash">sudo su - postgres
</code></pre>
<p>The typically installation for <code>rustc</code> uses <code>curl</code> and <code>rustup</code>.
If you want to install <code>rustc</code> without using <code>rustup</code> see the
<a href="https://forge.rust-lang.org/infra/other-installation-methods.html">Other Rust installation methods</a>
page.</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>The <code>rustup</code> installer prompts for an installation choice.  The
default installation (1) should work for most use cases.</p>
<pre><code class="language-bash">1) Proceed with installation (default)
2) Customize installation
3) Cancel installation
</code></pre>
<p>After installing rust, use <code>exit</code> to log out and back in to the <code>postgres</code>
account.  This ensures your terminal is using the newly installed
<code>rustc</code> installation.</p>
<pre><code class="language-bash"># Log in  as postgres fresh with rustc installed
exit
sudo su - postgres
</code></pre>
<h3 id="clone-plrust-and-check-rust-version"><a class="header" href="#clone-plrust-and-check-rust-version">Clone <code>plrust</code> and check Rust version</a></h3>
<p>PL/Rust is installed from source code using pgrx.  This installation
requires that pgrx is compiled using a specific version of <code>rustc</code>.
The <code>rustc</code> version required for PL/Rust is defined in the project's
<a href="https://github.com/tcdi/plrust/blob/main/rust-toolchain.toml"><code>rust-toolchain.toml</code></a>.
The steps below ensure the proper versions are used.</p>
<p>Clone the <code>plrust</code> repo from GitHub and change into the <code>plrust/plrust</code>
directory. Running <code>rustc -V</code> in this location is used to verify
the version reported is by <code>rustc -V</code> is the version defined by PL/Rust.</p>
<pre><code class="language-bash">git clone https://github.com/tcdi/plrust.git
cd plrust/plrust
rustc -V
</code></pre>
<p>The output from <code>rustc -V</code> should look similar to the following example.</p>
<pre><code>rustc 1.72.0 (90c541806 2023-05-31)
</code></pre>
<p>Use <code>rustup default</code> to check that the explicit version of <code>rustc</code> is
selected.
You need to see the version number reported in by <code>rustc -V</code> in
your <code>rustup default</code> output.</p>
<pre><code class="language-bash">rustup default
</code></pre>
<p>The expected output is below.</p>
<pre><code>1.72.0-x86_64-unknown-linux-gnu (default)
</code></pre>
<p>If <code>rustup default</code> returns a different version number or <code>stable</code>,
set the default version as shown below and check that the output
updates accordingly.</p>
<pre><code class="language-bash">rustup default 1.72.0
rustup default
</code></pre>
<h3 id="be-careful-with-rust-versions"><a class="header" href="#be-careful-with-rust-versions">Be careful with Rust versions</a></h3>
<blockquote>
<p><strong>WARNING!</strong> The <code>stable</code> version of <code>rustc</code> cannot be used to install Trusted PL/Rust.  This is the case even when the <code>stable</code> version is identical to the tagged version number, such as <code>1.72.0</code>.</p>
</blockquote>
<p>The above checks of <code>rustc -V</code> and <code>rustup default</code> are important to
follow before installing pgrx and PL/Rust.
You must install <code>pgrx</code> with the version of <code>rustc</code> that <code>plrust</code> expects
in the <code>rust-toolchain.toml</code>.  Failing to do so will result in a
mismatched version error in a subsequent step.</p>
<p>A misconfigured <code>rustup default</code> results in
errors when creating functions with trusted PL/Rust. The error can
manifest as a problem in the <code>postgrestd</code> linking with the following error.
This happens because Rust makes a distinction between the latest stable
version of Rust, and the actual version of the stable release (e.g. 1.72.0),
even when they refer to the same release.</p>
<pre><code class="language-bash">Error loading target specification: Could not find specification for target "x86_64-postgres-linux-gnu".
</code></pre>
<h2 id="install-pgrx"><a class="header" href="#install-pgrx">Install pgrx</a></h2>
<p>The PL/Rust extension is built and installed
<a href="https://github.com/tcdi/pgrx">using pgrx</a>.
Install pgrx with the <code>--locked</code> option. This step takes a few
minutes.</p>
<pre><code class="language-bash">cargo install cargo-pgrx --locked
</code></pre>
<p>Pgrx needs to be initialized for use with the PostgreSQL installation.
This is done using <code>pgrx init</code>.  This step needs to know where your
<code>pg_config</code> file is located at.  If you have a standard Ubuntu
<code>apt</code> installation of PostgreSQL with a single version of PostgreSQL
installed you can use the generic
<code>/usr/bin/pg_config</code> path.</p>
<pre><code class="language-bash">cargo pgrx init --pg15 /usr/bin/pg_config
</code></pre>
<p>Output from <code>cargo pgrx init</code> looks like the following example.
You may notice it mentions information about a new data directory under your
user's <code>~/.pgrx/</code> directory. This <strong>does not replace</strong> your PostgreSQL instance's
data directory. The <code>~/.pgrx/data-15/</code> directory is there in case you run
<code>cargo pgrx run pg15</code>, which would use this custom data directory, not your installation's data directory.</p>
<pre><code>   Validating /usr/bin/pg_config
 Initializing data directory at /var/lib/postgresql/.pgrx/data-15
</code></pre>
<p>The generic <code>pg_config</code> used above will not work
for all installations, such as if you have both PostgreSQL 14 and 15
installed on one instance.
In these cases you should specify the exact <code>pg_config</code>
file for your installation.</p>
<pre><code class="language-bash">cargo pgrx init --pg14 /usr/lib/postgresql/14/bin/pg_config
</code></pre>
<p>The instructions on this page have setup the prerequisite software required to
install PL/Rust.  The next section, <a href="install-plrust.html">Install PL/Rust</a>,
finishes the installation process.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-plrust"><a class="header" href="#install-plrust">Install PL/Rust</a></h1>
<p>This section provides steps on how to proceed with installing PL/Rust.  There
are three ways to install PL/Rust.
Most users will want to install <a href="install-plrust.html#trusted-install">trusted PL/Rust</a>.</p>
<ul>
<li><a href="install-plrust.html#untrusted-install">Untrusted</a></li>
<li><a href="install-plrust.html#trusted-install">Trusted</a></li>
<li><a href="install-plrust.html#trusted-installation-plus-cross-compilation">Trusted plus cross compilation</a></li>
</ul>
<p>These instructions assume you have followed the <a href="install-prerequisites.html">Install Prerequisites</a>
section and are logged in as the <code>postgres</code> Linux user.
Install PL/Rust by following the installation steps under your method of choice
below.  Then visit
<a href="install-plrust.html#configure-and-restart-postgresql">the configuration subsection</a>
and give <a href="install-plrust.html#try-it-out">PL/Rust a try</a>!</p>
<h3 id="untrusted-install"><a class="header" href="#untrusted-install">Untrusted install</a></h3>
<p>To install <strong>untrusted</strong> PL/Rust use <code>cargo pgrx install</code>
without <code>--features trusted</code>.  See the <a href="install-plrust.html#trusted-install">trusted install</a> if you
wish to install the trusted PL/Rust instead.</p>
<pre><code class="language-bash">cargo pgrx install --release -c /usr/bin/pg_config
</code></pre>
<p>Continue on to <a href="install-plrust.html#configure-and-restart-postgresql">configuring PostgreSQL</a>
for PL/Rust.</p>
<h3 id="trusted-install"><a class="header" href="#trusted-install">Trusted install</a></h3>
<p>The trusted installation requires <code>postgrestd</code> and a few additional
Rust dependencies.  First install the additional dependencies.  This example
uses <code>x86_64</code> and ensures the target is installed.  If you are using <code>aarch64</code>,
update the command accordingly.</p>
<p>Linux:</p>
<pre><code class="language-bash">rustup component add llvm-tools-preview rustc-dev
rustup target install x86_64-unknown-linux-gnu
</code></pre>
<p>macOS:</p>
<pre><code class="language-bash">rustup component add llvm-tools-preview rustc-dev
rustup target install x86_64-apple-darwin
</code></pre>
<p>Change into the <code>plrust/plrustc</code> directory to build <code>plrustc</code>.
Move the generated binary into <code>~/.cargo/bin/</code>.</p>
<pre><code class="language-bash">cd ~/plrust/plrustc
./build.sh
mv ~/plrust/build/bin/plrustc ~/.cargo/bin/
</code></pre>
<blockquote>
<p>Note:  The path <code>~/.cargo/bin/</code> is the default path used by PL/Rust. This can be overridden using <code>plrust.PATH_override</code>, see <a href="./config-pg.html">PostgreSQL Config</a>.</p>
</blockquote>
<p>Change into the <code>plrust/plrust/</code> directory and run the build process to
install <code>postgrestd</code>.  This example is for installing PL/Rust on <code>x86_64</code>
architecture, switch to <code>aarch64</code> if using that architecture instead.</p>
<pre><code class="language-bash">cd ~/plrust/plrust
PG_VER=15 \
    STD_TARGETS="x86_64-postgres-linux-gnu " \
    ./build
</code></pre>
<p>The above step can take quite a few minutes to
install <code>postgrestd</code> and run the associated tests.
It is not uncommon to see output like the following during the
test process.</p>
<pre><code class="language-bash">test tests::tests::pg_plrust_aggregate has been running for over 60 seconds
</code></pre>
<p>The final step for trusted PL/Rust installation is to use
<code>cargo pgrx install</code> with <code>--features trusted</code>.</p>
<pre><code class="language-bash">cargo pgrx install --release --features trusted -c /usr/bin/pg_config
</code></pre>
<p>Continue on to <a href="install-plrust.html#configure-and-restart-postgresql">configuring PostgreSQL</a>
for PL/Rust.</p>
<h3 id="choosing-a-different-plrust-trusted-pgrx-dependency-at-compile-time"><a class="header" href="#choosing-a-different-plrust-trusted-pgrx-dependency-at-compile-time">Choosing a different <code>plrust-trusted-pgrx</code> dependency at compile time</a></h3>
<p>When a user creates a <code>LANGUAGE plrust</code> function, PL/Rust first generates a small Cargo crate for the function.  That
crate has a dependency on <code>plrust-trusted-pgrx</code>.  By default, <code>plrust-trusted-pgrx</code> comes from crates.io, using the same
version as PL/Rust itself.</p>
<p>It is possible to override this dependency when compiling PL/Rust itself so that PL/Rust will use a different
<code>plrust-trusted-pgrx</code> crate.  To do this, set an environment variable named <code>PLRUST_TRUSTED_PGRX_OVERRIDE</code> to the
full "Cargo.toml"-compatible dependency line, like so:</p>
<pre><code class="language-shell">PLRUST_TRUSTED_PGRX_OVERRIDE="pgrx = { path = '~/code/plrust/plrust-trusted-pgrx', package='plrust-trusted-pgrx' }" \
cargo pgrx install --release --features trusted -c /usr/bin/pg_config
</code></pre>
<p>This will instead compile all user functions using this specific <code>plrust-trusted-pgrx</code>, not the default on crates.io.
Generally, changing the <code>plrust-trusted-pgrx</code> dependency is only useful for PL/Rust development and CI, not for production
deployments, but is worth mentioning as the environment variable <em>will</em> influence how user functions are compiled.</p>
<p>It may also be useful for providing a local patch to <code>plrust-trusted-pgrx</code> if such a need were to arise.</p>
<h3 id="trusted-installation-plus-cross-compilation"><a class="header" href="#trusted-installation-plus-cross-compilation">Trusted installation plus cross compilation</a></h3>
<p>Adding cross compilation support to PL/Rust requires a few minor changes to the
<a href="install-plrust.html#trusted-install">trusted installation</a> steps above.  This section only highlights
the changes to make for cross compile support, not the full process.</p>
<h4 id="linux"><a class="header" href="#linux">Linux</a></h4>
<p>As a Linux user with <code>sudo</code> access, install these additional prerequisites.</p>
<pre><code class="language-bash">sudo apt install crossbuild-essential-arm64 crossbuild-essential-amd64
</code></pre>
<p>The normal trusted install uses <code>rustup</code> to install one architecture target.
Cross compilation support requires both.</p>
<pre><code class="language-bash">rustup component add llvm-tools-preview rustc-dev
rustup target install aarch64-unknown-linux-gnu
rustup target install x86_64-unknown-linux-gnu
</code></pre>
<h4 id="macos"><a class="header" href="#macos">macOS</a></h4>
<p>The normal trusted install uses <code>rustup</code> to install one architecture target.
Cross compilation support requires both.</p>
<pre><code class="language-bash">rustup component add llvm-tools-preview rustc-dev
rustup target install aarch64-apple-darwin
rustup target install x86_64-apple-darwin
</code></pre>
<blockquote>
<p>The above environment variables are the default... you can just run <code>./build</code>.  <code>PG_VER=15</code> currently represents the latest released PostgreSQL version.</p>
</blockquote>
<h2 id="configure-and-restart-postgresql"><a class="header" href="#configure-and-restart-postgresql">Configure and restart PostgreSQL</a></h2>
<p>The PostgreSQL configuration in <code>postgresql.conf</code> must be updated for PL/Rust
to function. This section illustrates the minimum required changes so PL/Rust
will function.
See the <a href="./config-pg.html">PostgreSQL configuration</a> section for more configuration details.</p>
<p>PL/Rust requires <code>shared_preload_libraries</code> includes <code>plrust</code> and that you
define <code>plrust.work_dir</code>.</p>
<blockquote>
<p>NOTE:  PL/Rust with cross compilation support also requires <code>plrust.compilation_targets</code>.</p>
</blockquote>
<p>Edit the PostgreSQL configuration file still as the <code>postgres</code> Linux user.</p>
<pre><code class="language-bash">nano /etc/postgresql/15/main/postgresql.conf
</code></pre>
<p>Update the configuration with these items.  Note that <code>shared_preload_libraries</code>
might already be set with a value before you add <code>plrust</code>.  Use a comma separated
list of extensions to include multiple libraries in this configuration option.</p>
<pre><code>shared_preload_libraries = 'plrust'
plrust.work_dir = '/tmp'
</code></pre>
<p>The PostgreSQL service needs to be restarted for the configuration changes
to take effect. Exit the <code>postgres</code> user and restart the PostgreSQL service.</p>
<pre><code class="language-bash">exit
sudo systemctl restart postgresql
</code></pre>
<h2 id="reset-permissions"><a class="header" href="#reset-permissions">Reset permissions</a></h2>
<p>In order to install the PL/Rust extension as the <code>postgres</code> users permissions
were updated in the <a href="install-prerequisites.html#permissions">Permissions section</a>
of the Install PL/Rust Prerequisites section.
Change the permissions for the <code>extension</code> and <code>lib</code> folders back
to being owned by the <code>root</code> user.</p>
<pre><code class="language-bash">sudo chown root -R /usr/share/postgresql/15/extension/
sudo chown root -R /usr/lib/postgresql/15/lib/
</code></pre>
<h2 id="try-it-out"><a class="header" href="#try-it-out">Try it out</a></h2>
<p>Create a <code>plrust</code> database and connect to the <code>plrust</code> database
using <code>psql</code>.</p>
<p>PL/Rust only supports databases encoded as <code>UTF8</code>.  This is to ensure proper compatibility between Postgres/SQL <code>TEXT</code>
(and internal strings) and Rust <code>String</code> and <code>&amp;str</code> types.</p>
<pre><code class="language-bash">sudo -u postgres psql -c "CREATE DATABASE plrust WITH ENCODING = 'utf8' TEMPLATE = 'template0';"
sudo -u postgres psql -d plrust
</code></pre>
<p>Create the <code>plrust</code> extension.</p>
<pre><code class="language-sql">CREATE EXTENSION plrust;
</code></pre>
<p>If you installed the untrusted PL/Rust you will be warned of that detail
in this step.</p>
<pre><code class="language-bash">WARNING:  plrust is **NOT** compiled to be a trusted procedural language
</code></pre>
<p>The following example creates a <code>plrust</code> function named <code>plrust.one()</code>
that simply returns the integer 1.</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION plrust.one()
    RETURNS INT LANGUAGE plrust
AS
$$
    Ok(Some(1))
$$;
</code></pre>
<p>Using a function created with PL/Rust is the same as using any other
PostgreSQL function.  A scalar function like <code>plrust.one()</code> can
be used simply like below.</p>
<pre><code class="language-sql">SELECT plrust.one();
</code></pre>
<pre><code>┌─────┐
│ one │
╞═════╡
│   1 │
└─────┘
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="update-plrust"><a class="header" href="#update-plrust">Update PL/Rust</a></h1>
<p>This section explains how to update PL/Rust installations.  This assumes
you installed PL/Rust following our <a href="./install-plrust.html">installation guide</a> and pgrx and PL/Rust are installed using the <code>postgres</code> Linux user.</p>
<h2 id="update-pgrx"><a class="header" href="#update-pgrx">Update pgrx</a></h2>
<p>A PL/Rust update is often accompanied by an update of the underlying
<code>pgrx</code> project.  Install the latest version of pgrx.
Changing into the plrust folder ensures the <code>rustc</code> version used
for installation is the same required by PL/Rust.</p>
<p>Start as a user with <code>sudo</code> access.</p>
<pre><code class="language-bash">sudo chown postgres -R /usr/share/postgresql/15/extension/
sudo chown postgres -R /usr/lib/postgresql/15/lib/
</code></pre>
<pre><code class="language-bash">sudo su - postgres
cd ~/plrust
git pull
cargo install cargo-pgrx --locked
</code></pre>
<h2 id="update-plrust-1"><a class="header" href="#update-plrust-1">Update PL/Rust</a></h2>
<p>Follow these steps to upgrade PL/Rust from GitLab to use
the latest release.</p>
<p>Update <code>plrustc</code>, <code>postgrestd</code> and <code>plrust</code> installations.</p>
<pre><code class="language-bash">cd ~/plrust/plrustc
./build.sh
mv ~/plrust/build/bin/plrustc ~/.cargo/bin/

cd ~/plrust/plrust
PG_VER=15 \
    STD_TARGETS="x86_64-postgres-linux-gnu " \
    ./build

cargo pgrx install --release \
    --features trusted \
    -c /usr/bin/pg_config
</code></pre>
<p>Exit out of <code>postgres</code> user back to user with sudo.</p>
<pre><code class="language-bash">exit
</code></pre>
<p>Restart Postgres, required b/c plrust is in <code>shared_preload_libraries</code>.
Set permissions back to default.</p>
<pre><code class="language-bash">sudo systemctl restart postgresql

sudo chown root -R /usr/share/postgresql/15/extension/
sudo chown root -R /usr/lib/postgresql/15/lib/
</code></pre>
<h2 id="rust-versions"><a class="header" href="#rust-versions">Rust versions</a></h2>
<p>See the section(s) about Rust versions
the the <a href="./install-plrust.html">Install PL/Rust</a> section.
Pay special attention to the versions defined by PL/Rust, and your
system defaults for <code>rustc</code> and <code>rustup</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-plrust-on-debianubuntu"><a class="header" href="#install-plrust-on-debianubuntu">Install PL/Rust on Debian/Ubuntu</a></h1>
<p>Debian packages for PL/Rust are available for download on the Github Releases page here: <a href="https://github.com/tcdi/plrust/releases">https://github.com/tcdi/plrust/releases</a></p>
<h2 id="assumptions"><a class="header" href="#assumptions">Assumptions</a></h2>
<p>The provided Debian packages for PL/Rust make certain assumptions about the environment in which they are installed. Notably, they require PostgreSQL either has been installed or will be installed with the official <a href="https://www.postgresql.org/download/linux/debian/">Postgres Debian packages</a>. Because of this, the PL/Rust Debian packages assume:</p>
<ul>
<li>The user which runs Postgres is <code>postgres</code></li>
<li>The home directory for the <code>postgres</code> user is located at <code>/var/lib/postgresql</code></li>
<li>The <code>postgres</code> user has the ability to create and manage databases and extensions</li>
<li>The <code>postgres</code> user has the ability to install Rust and all of the required dependencies</li>
</ul>
<h2 id="filename-convention"><a class="header" href="#filename-convention">Filename convention</a></h2>
<p>The PL/Rust artifacts that are uploaded to Github releases follow this pattern:</p>
<pre><code>plrust-trusted-&lt;PLRUSTVER&gt;_&lt;RUSTTOOLCHAINVER&gt;-debian-pg&lt;PGMAJORVER&gt;-&lt;DPKGARCH&gt;.deb
</code></pre>
<p>Where:</p>
<ul>
<li>PLRUSTVER is the PL/Rust release version</li>
<li>RUSTTOOLCHAINVER is the version of Rust+toolchains in which the Debian package was built</li>
<li>PGMAJORVER is the major version of PostgreSQL the package targets, such as 13, 14 or 15</li>
<li>DPKGARCH is the CPU architecture name according to <code>dpkg</code>, such as <code>arm64</code> or <code>amd64</code></li>
</ul>
<p>Example:</p>
<pre><code>plrust-trusted-1.2.3_1.72.0-debian-pg15-amd64.deb
</code></pre>
<h2 id="preparing-the-environment"><a class="header" href="#preparing-the-environment">Preparing the environment</a></h2>
<p>Certain applications, libraries and dependencies must be set up before PL/Rust can be installed from a Debian package.</p>
<p>Note that the following instructions assume <code>sudo</code> capabilities.</p>
<h3 id="system-and-development-requirements"><a class="header" href="#system-and-development-requirements">System and development requirements</a></h3>
<p>Because PL/Rust is a compiled language, certain libraries and development tools will be required to be installed:</p>
<pre><code>sudo apt-get update &amp;&amp; \
sudo apt-get install -y --no-install-recommends \
    build-essential \
    ca-certificates \
    clang \
    clang-11 \
    gcc \
    git \
    gnupg \
    libssl-dev \
    llvm-11 \
    lsb-release \
    make \
    pkg-config \
    wget
</code></pre>
<h3 id="installing-postgres"><a class="header" href="#installing-postgres">Installing Postgres</a></h3>
<p>If Postgres has already been installed with the official <a href="https://www.postgresql.org/download/linux/debian/">Postgres Debian packages</a>, then skip this section and proceed to <a href="install-plrust-on-debian-ubuntu.html#installing-rust-and-components">Installing Rust and components</a></p>
<ol>
<li>Set up the official PostgreSQL APT repository:
<pre><code>echo "deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" | \
  sudo tee -a /etc/apt/sources.list.d/pgdg.list &gt; /dev/null
</code></pre>
<pre><code>wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | \
  gpg --dearmor | sudo tee -a /etc/apt/trusted.gpg.d/apt.postgresql.org.gpg &gt;/dev/null
</code></pre>
</li>
<li>Update APT and install PostgreSQL. Replace <code>XX</code> with the PostgreSQL major version to be installed (e.g. 13, 14, 15):
<pre><code>sudo apt-get update -y -qq --fix-missing &amp;&amp; \
sudo apt-get install -y --no-install-recommends \
    postgresql-XX \
    postgresql-server-dev-XX
</code></pre>
</li>
</ol>
<h3 id="installing-rust-and-components"><a class="header" href="#installing-rust-and-components">Installing Rust and components</a></h3>
<p>A key component of making PL/Rust work is the Rust compiler and components. However, Rust and its tooling must be installed as the <code>postgres</code> user. If the package-required version of Rust and toolchains are already installed and defaulted for the <code>postgres</code> user, then skip this section and proceed to <a href="install-plrust-on-debian-ubuntu.html#installing-plrust">Installing PL/Rust</a>.</p>
<p>Instructions that follow assume the latest version of PL/Rust, which requires <code>1.72.0</code> of Rust and toolchain set. If the desired PL/Rust Debian package requires a different version of the toolchain set (as indicated by the <a href="install-plrust-on-debian-ubuntu.html#filename-convention">filename</a>), then substitute that version in the following instructions.</p>
<ol>
<li>Switch to the <code>postgres</code> user:
<pre><code>sudo su -l - postgres
</code></pre>
</li>
<li>If Rust has never been installed as the <code>postgres</code> user, then run the following:
<pre><code>wget -qO- https://sh.rustup.rs | \
  sh -s -- \
  -y \
  --profile minimal \
  --default-toolchain=1.72.0

source "$HOME/.cargo/env"
</code></pre>
</li>
<li>If Rust has previously been installed as the <code>postgres</code> user, then ensure that the <code>1.72.0</code> toolchain is installed and set to default:
<pre><code>rustup toolchain install 1.72.0
rustup default 1.72.0
</code></pre>
</li>
<li>Ensure that the <code>rustc-dev</code> component has been installed:
<pre><code>rustup component add rustc-dev
</code></pre>
</li>
<li>Drop back to your normal user:
<pre><code>exit
</code></pre>
</li>
</ol>
<p>Future versions of PL/Rust may require a different version of the Rust toolchain to be installed and set to default. In such an event, step 3 and onward must be repeated with the new required version of the specific toolchain. The filename of the PL/Rust Debian package contains the version of the Rust toolchain it was built with -- see <a href="install-plrust-on-debian-ubuntu.html#filename-convention">Filename convention</a> for more details.</p>
<h3 id="installing-plrust"><a class="header" href="#installing-plrust">Installing PL/Rust</a></h3>
<p>With the prerequisites installed and set up, it is time to install the PL/Rust Debian package.</p>
<ol>
<li>Head to <a href="https://github.com/tcdi/plrust/releases">the PL/Rust releases page</a> and download the appropriate version onto the target system. When choosing a destination in which to place the dowloaded Debian package, pick a directory that is readable and writable by the <code>_apt</code> user, such <code>/tmp</code>. Otherwise, the installation might produce an error.</li>
<li>Install the package:
<pre><code>sudo apt install /tmp/plrust-trusted-X.X.X_1.72.0-debian-pgXX-yourarch.deb
</code></pre>
</li>
</ol>
<p>The package installation will fail if at least one of the above Rust dependencies are not met.</p>
<h4 id="service-restart-notice"><a class="header" href="#service-restart-notice">Service Restart Notice</a></h4>
<p>Newer versions of Debian/Ubuntu may prompt for a restart of certain services during the Debian package installation process, notably the PostgreSQL server service. Take caution in determining the appropriate time for the PostgreSQL service to be restarted. For example, if the GUC settings have not been set up before as outlined in the following <a href="install-plrust-on-debian-ubuntu.html#configuring-postgresql">Configuring PostgreSQL</a> section, then it may be advisable to delay the restart until after those are set up. It may also be advisable to delay a restart for a system that is already in production.</p>
<p>Regardless of timing, PostgreSQL will need to be restarted in any of the following conditions:</p>
<ol>
<li>PL/Rust is installed for the first time and GUC additions have been added</li>
<li>PL/Rust is updated on an existing system at some point in the future, with or without GUC changes</li>
<li>Any GUC change is required for an existing PL/Rust setup</li>
</ol>
<h3 id="configuring-postgresql"><a class="header" href="#configuring-postgresql">Configuring PostgreSQL</a></h3>
<p>In order for PL/Rust to be available to the PostgreSQL server, some new <a href="https://www.postgresql.org/docs/current/config-setting.html">GUC</a> settings must configured. See the <a href="config-pg.html">PostgreSQL Configuration for PL/Rust</a> for more details on the required setup and other options that may be necessary.</p>
<p>Any configuration changes will require a restart of the PostgreSQL service on the system.</p>
<h3 id="finishing-up"><a class="header" href="#finishing-up">Finishing up</a></h3>
<p>To test if PL/Rust is set up correctly, load up <code>psql</code> as the <code>postgres</code> user</p>
<pre><code>sudo su -l - postgres
psql
</code></pre>
<p>and run the following:</p>
<pre><code class="language-SQL">CREATE EXTENSION plrust;
</code></pre>
<p>Then, create a simple function and try it out:</p>
<pre><code class="language-SQL">CREATE OR REPLACE FUNCTION plrust.one()
    RETURNS INT LANGUAGE plrust
AS
$$
    Ok(Some(1))
$$;
</code></pre>
<pre><code class="language-SQL">SELECT plrust.one();
</code></pre>
<pre><code>┌─────┐
│ one │
╞═════╡
│   1 │
└─────┘
</code></pre>
<h2 id="updating"><a class="header" href="#updating">Updating</a></h2>
<p>Future versions of PL/Rust can be installed using the same methods described in <a href="install-plrust-on-debian-ubuntu.html#installing-plrust">Installing PL/Rust</a>. One consideration when upgrading is that new versions of PL/Rust may require a different version of the Rust toolchain. See <a href="install-plrust-on-debian-ubuntu.html#installing-rust-and-components">Installing Rust and components</a> for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="try-plrust-with-docker"><a class="header" href="#try-plrust-with-docker">Try PL/Rust with Docker</a></h1>
<p>Giving PL/Rust a try has never been easier with Docker! This document outlines what is required to get a functional Postgres + PL/Rust environment running with just a few commands.</p>
<p>The PL/Rust repository supplies a Dockerfile named <code>Dockerfile.try</code> that contains everything necessary to spin up and test PL/Rust in a target environment.</p>
<p>The following instructions assume a very basic understanding of what <a href="https://www.docker.com">Docker</a> is and that it is already installed in the target environment. If Docker is not yet installed, instructions can be found here: <a href="https://docs.docker.com/engine/install/">https://docs.docker.com/engine/install/</a></p>
<ol>
<li>Clone the PL/Rust code, and switch to that directory</li>
<li>From a command line, run the following from the root of the checkout directory (<code>sudo</code> or equivalent may be required):
<pre><code>docker build -f Dockerfile.try -t tcdi/try-plrust .
</code></pre>
Note that this may take a little while to finish.</li>
<li>Once the above has finished, run the following (<code>sudo</code> may be required here):
<pre><code>docker run -it tcdi/try-plrust
</code></pre>
</li>
<li>There will be some output that the Postgres server has started, and <code>psql</code> prompt will start up in the foreground:
<pre><code>Type "help" for help.

postgres(plrust)=#
</code></pre>
</li>
</ol>
<p>That's it! From here, the <code>psql</code> interactive prompt with PL/Rust installed can be used to create and run PL/Rust functions. Here is a very small example to get started:</p>
<pre><code class="language-SQL">CREATE FUNCTION plrust.one()
    RETURNS INT LANGUAGE plrust
AS
$$
    Ok(Some(1))
$$;
</code></pre>
<p>Creating PL/Rust functions compiles Rust code in the backend, so this may take some time depending on the host's hardware specifications and internet connection speeds. Once this completes, the PL/Rust function can be executed similar to other Postgres functions:</p>
<pre><code class="language-SQL">SELECT * FROM plrust.one();
</code></pre>
<p>which will provide the following results:</p>
<pre><code>postgres(plrust)=# SELECT * FROM plrust.one();
 one
-----
   1
(1 row)
</code></pre>
<p>To exit out of the prompt and the Docker container, type the Postgres command <code>quit</code>:</p>
<pre><code>postgres(plrust)=# quit
</code></pre>
<h2 id="alternate-running-modes"><a class="header" href="#alternate-running-modes">Alternate running modes</a></h2>
<p>Running the Docker container using <code>docker run -it tcdi/try-plrust</code> as described above will spin up both the Postgres server in the background and the <code>psql</code> command line utility in the foreground in the same running container. However, the option exists to run the Postgres server only (with PL/Rust installed) so that an alternative Postgres client can be used. To do this, run the following command (which may require <code>sudo</code> or equivalent):</p>
<pre><code>docker run -it -p 5432:5432 tcdi/try-plrust server
</code></pre>
<p>This will set up everything that is necessary and run the Postgres server only, binding to TCP port 5432. Output here will be all of the Postgres log entries, including any errors that result from a PL/Rust compilation error. The final <code>server</code> argument in the command indicates that it should launch the <code>server</code> script upon container bootup. In order to connect with an alternative client, the only pieces of information that are required are the Postgres username (<code>postgres</code>), the hostname or IP address (e.g. <code>localhost</code> or <code>192.168.0.2</code>) and the port (<code>5432</code>). There is no password set for the <code>postgres</code> user in this setup. An example Postgres URI might look like this:</p>
<pre><code>postgres://postgres@localhost:5432
</code></pre>
<p>To exit out of server mode, press Ctrl+c in the running Docker container.</p>
<h2 id="caveats"><a class="header" href="#caveats">Caveats</a></h2>
<ul>
<li>
<p>This Dockerfile and resulting image should not be used in production. It does not take many security precautions into consideration. As such, the way <code>Dockerfile.try</code> is constructed should not be considered a best practice as it relates to setting up and securing a Postgres instance with PL/Rust installed.</p>
</li>
<li>
<p>The Postgres data directories, logs and built PL/Rust functions are not persistent and are destroyed upon container termination. Externally mounting Postgres' data, log and function directories is outside the scope of this example.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plrust-functions"><a class="header" href="#plrust-functions">PL/Rust Functions</a></h1>
<p>PL/Rust functions are created with the standard
<a href="https://www.postgresql.org/docs/current/sql-createfunction.html"><code>CREATE FUNCTION</code></a>
syntax and <code>LANGUAGE plrust</code>.
This section provides examples how to create a variety
of function using PL/Rust.</p>
<p>The basic function structure is shown in the following example.</p>
<pre><code class="language-sql">CREATE FUNCTION funcname (argument-list)
    RETURNS return-type
    -- function attributes can go here
AS $$
    # PL/Rust function body goes here
$$ LANGUAGE plrust;
</code></pre>
<p>The body of the function is ordinary
Rust code. When the <code>CREATE FUNCTION</code> is ran the Rust code is
complied using the <code>pgrx</code> framework.
This compile process can take a bit of time.
The compile time required is one reason anonymous blocks (<code>DO</code> blocks)
are not supported at this time.</p>
<p>The syntax of the <code>CREATE FUNCTION</code> command requires the function
body to be written as a string constant. It is usually most convenient
to use dollar quoting (<code>$$</code>, see <a href="https://www.postgresql.org/docs/current/sql-syntax-lexical.html#SQL-SYNTAX-DOLLAR-QUOTING">Section 4.1.2.4</a>)
for the string constant. If you choose to use escape string syntax
<code>E''</code>, you must double any single quote marks (') and
backslashes () used in the body of the function (see
<a href="https://www.postgresql.org/docs/current/sql-syntax-lexical.html#SQL-SYNTAX-STRINGS">Section 4.1.2.1</a>).</p>
<h2 id="basic-plrust-example"><a class="header" href="#basic-plrust-example">Basic PL/Rust Example</a></h2>
<p>The following example creates a basic <code>plrust</code> function named
<code>plrust.one()</code> to simply returns the integer <code>1</code>.</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION plrust.one()
    RETURNS INT
    LANGUAGE plrust
AS
$$
    Ok(Some(1))
$$
;
</code></pre>
<h2 id="function-with-parameters"><a class="header" href="#function-with-parameters">Function with parameters</a></h2>
<p>The following example creates a function named <code>plrust.strlen</code>
that accepts one parameter named <code>val</code>. The function returns a <code>BIGINT</code> representing the length of the text in <code>val</code>.  The variable names
defined in the function definition can be used directly in the Rust
code within the function's body.</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION plrust.strlen(val TEXT)
    RETURNS BIGINT
    LANGUAGE plrust
AS $$
    Ok(Some(val.unwrap().len() as i64))
$$;
</code></pre>
<p>Using the <code>strlen()</code> function works as expected.</p>
<pre><code class="language-sql">SELECT plrust.strlen('Hello, PL/Rust');
</code></pre>
<pre><code>┌────────┐
│ strlen │
╞════════╡
│     14 │
└────────┘
</code></pre>
<p>The <code>plrust.strlen</code> function above used <code>unwrap()</code> to parse the
text variable. Changing the function definition to include <code>STRICT</code>
avoids the need to use <code>unwrap()</code>.  The following version
of <code>plrust.strlen</code> works the same as above.</p>
<pre><code class="language-sql">    CREATE OR REPLACE FUNCTION plrust.strlen(val TEXT)
    RETURNS BIGINT
    LANGUAGE plrust STRICT
AS $$
    Ok(Some(val.len() as i64))
$$;
</code></pre>
<h3 id="functions-with-anonymous-parameters-not-allowed"><a class="header" href="#functions-with-anonymous-parameters-not-allowed">Functions with anonymous parameters not allowed</a></h3>
<p>PL/Rust functions with parameters require named parameters.
This is different from functions written in other languages,
such as SQL where <code>strlen(TEXT, INT)</code> allows the use of
<code>$1</code> and <code>$2</code> within the function body.</p>
<p>https://www.postgresql.org/docs/current/sql-createfunction.html</p>
<p>The succinct reason anonymous parameters are not allowed is because
"It does not align with Rust."  Requiring named parameters
keeps functionality simple, direct and obvious.</p>
<p>One of the reasons people use Rust is because of the quality of the compiler's feedback on incorrect code. Allowing anonymous parameters would ultimately require transforming the code in a way that would either result in potentially garbled error messages, or arbitrarily restricting what sets of identifiers can be used. Simply requiring identifiers skips all of that.</p>
<h2 id="calculations"><a class="header" href="#calculations">Calculations</a></h2>
<p>PL/Rust functions can performance calculations, such as converting
distance values from feet to miles.</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION plrust.distance_feet_to_miles(feet FLOAT)
    RETURNS FLOAT
    LANGUAGE plrust STRICT
AS $$
    Ok(Some(feet / 5280.0))
$$;
</code></pre>
<p>Using the function.</p>
<pre><code class="language-sql">SELECT plrust.distance_feet_to_miles(10000);
</code></pre>
<pre><code>┌────────────────────────┐
│ distance_feet_to_miles │
╞════════════════════════╡
│      1.893939393939394 │
└────────────────────────┘
</code></pre>
<h2 id="use-dependencies"><a class="header" href="#use-dependencies">Use dependencies</a></h2>
<p>One of the powerful features of <code>plrust</code> is its ability to define <code>dependencies</code>
in the function.  The following examples use the
<a href="https://docs.rs/faker_rand/latest/faker_rand/index.html"><code>faker_rand</code> crate</a>
in functions to generate fake text data.</p>
<p>The <code>random_first_name()</code> function returns a random first name using the
<code>en_us</code> locale.</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION plrust.random_slogan() RETURNS TEXT
LANGUAGE plrust AS $$
[dependencies]
    faker_rand = "0.1"
    rand = "0.8"
[code]
    use faker_rand::en_us::company::Slogan;
    Ok(Some(rand::random::&lt;Slogan&gt;().to_string()))
$$;
</code></pre>
<pre><code class="language-sql">SELECT plrust.random_slogan();
</code></pre>
<pre><code>┌─────────────────────────────┐
│        random_slogan        │
╞═════════════════════════════╡
│ Ergonomic composite schemas │
└─────────────────────────────┘
</code></pre>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION plrust.random_company_name(locale TEXT)
    RETURNS TEXT
    LANGUAGE plrust STRICT
AS $$
[dependencies]
    faker_rand = "0.1"
    rand = "0.8"
[code]
    match locale {
        "en_us" =&gt; {
            use faker_rand::en_us::company::CompanyName;
            Ok(Some(rand::random::&lt;CompanyName&gt;().to_string()))
        }
        "fr_fr" =&gt; {
            use faker_rand::fr_fr::company::CompanyName;
            Ok(Some(rand::random::&lt;CompanyName&gt;().to_string()))
        }
        _ =&gt; panic!("Unsupported locale. Use en_us or fr_fr")
    }
$$;
</code></pre>
<pre><code class="language-sql">SELECT plrust.random_company_name('en_us') AS en_us,
    plrust.random_company_name('fr_fr') AS fr_fr;
</code></pre>
<pre><code>┌────────────┬───────────────┐
│   en_us    │     fr_fr     │
╞════════════╪═══════════════╡
│ Furman Inc │ Élisabeth SEM │
└────────────┴───────────────┘
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-anatomy"><a class="header" href="#function-anatomy">Function Anatomy</a></h1>
<p>A PL/Rust function is Rust code embedded in an SQL <code>CREATE FUNCTION</code> statement.  Behind the scenes, PL/Rust injects
the function body into a true Rust function, automatically creating the wrapper function signature along with applying
a set of lints.</p>
<p>It's important to understand the surrounding code environment of an individual <code>LANGUAGE plrust</code> function, and this
environment is different depending on certain properties of the function itself.  The important differences arise around
whether the function is declared as <code>STRICT</code>.  This is discussed in the <a href="functions/arguments.html"><code>STRICT</code> and <code>NULL</code></a> chapter.</p>
<p>Using a PL/Rust function that converts a <code>TEXT</code> datum to lowercase:</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION lcase(s TEXT) RETURNS TEXT LANGUAGE plrust AS $$
    Ok(Some(s.unwrap().to_lowercase())) 
$$;
</code></pre>
<p>PL/Rust then generates the following Rust code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod forbidden {
       #![forbid(deprecated)]
       #![forbid(implied_bounds_entailment)]
       #![forbid(plrust_async)]
       #![forbid(plrust_autotrait_impls)]
       #![forbid(plrust_env_macros)]
       #![forbid(plrust_extern_blocks)]
       #![forbid(plrust_external_mod)]
       #![forbid(plrust_filesystem_macros)]
       #![forbid(plrust_fn_pointers)]
       #![forbid(plrust_leaky)]
       #![forbid(plrust_lifetime_parameterized_traits)]
       #![forbid(plrust_print_macros)]
       #![forbid(plrust_static_impls)]
       #![forbid(plrust_stdio)]
       #![forbid(plrust_suspicious_trait_object)]
       #![forbid(soft_unstable)]
       #![forbid(suspicious_auto_trait_impls)]
       #![forbid(unsafe_code)]
       #![forbid(where_clauses_object_safety)]
    
       #[allow(unused_imports)]
       use pgrx::prelude::*;
    
       #[allow(unused_lifetimes)]
       fn plrust_fn_oid_16384_16404&lt;'a&gt;(
           s: Option&lt;&amp;'a str&gt;,
       ) -&gt; ::std::result::Result&lt;
           Option&lt;String&gt;,
           Box&lt;dyn std::error::Error + Send + Sync + 'static&gt;,
       &gt; {
           Ok(Some(s.unwrap().to_lowercase()))
       }
   }
<span class="boring">}</span></code></pre></pre>
<h3 id="mod-forbidden-"><a class="header" href="#mod-forbidden-"><code>mod forbidden {}</code></a></h3>
<p>Every PL/Rust function is wrapped with this module and cannot be influenced by users.  It exists so that PL/Rust can
apply <a href="functions/../config-lints.html">lints</a> to the user's code which will detect forbidden code patterns and idioms at compile time.</p>
<h3 id="forbid"><a class="header" href="#forbid"><code>#[!forbid(...)]</code></a></h3>
<p>These are the lints that, if triggered, will fail compilation.  These <a href="functions/../config-lints.html">lints</a> are only applied here
and are not applied to external dependencies.</p>
<h3 id="use-pgrxprelude"><a class="header" href="#use-pgrxprelude"><code>use pgrx::prelude::*</code></a></h3>
<p>A default set of types and traits available to every PL/Rust function.  Despite the name, these originate from
<a href="https://docs.rs/plrust-trusted-pgrx/latest/plrust_trusted_pgrx/"><code>plrust-trusted-pgrx</code></a>.  <code>plrust-trusted-pgrx</code> is a very
small subset of <code>pgrx</code>, the crate upon which PL/Rust <em>and</em> <code>LANGUAGE plrust</code> functions are based.</p>
<h3 id="fn-plrust_fn_oid_16384_16404----"><a class="header" href="#fn-plrust_fn_oid_16384_16404----"><code>fn plrust_fn_oid_16384_16404(...) -&gt; ... {}</code></a></h3>
<p>The function in which the <code>LANGUAGE plrust</code> function body is injected.  The naming convention is the literal string
<code>plrust_fn_oid_</code>, then the database's <code>OID</code>, an underscore, and the function's <code>OID</code>.</p>
<p>A PL/Rust function author does not need to know this function name and would never have a reason to call it directly, but
it's important to know how the name is generated.</p>
<p>Generation of the function's <a href="functions/arguments.html">arguments</a> and <a href="functions/return-type.html">return type</a> are discussed in more detail in
their respective sections.</p>
<h3 id="oksomesunwrapto_lowercase"><a class="header" href="#oksomesunwrapto_lowercase"><code>Ok(Some(s.unwrap().to_lowercase()))</code></a></h3>
<p>The function body itself.  This is injected, unchanged, directly from the body of the <code>CREATE FUNCTION</code> statement.</p>
<p>It's worth nothing that the function body is parsed for syntactic correctness by the Rust crate <code>syn</code> prior to
generating the entire block of code outlined here.  This means PL/Rust doesn't rely on the compiler for syntax checking
-- it happens up-front.  As such, syntax errors may report error messages that are sometimes unhelpful.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-arguments"><a class="header" href="#function-arguments">Function Arguments</a></h1>
<p>PL/Rust function arguments are mapped in the same order declared by the <code>CREATE FUNCTION</code> statement.  They'll have the
same names and the types will be mapped following the <a href="functions/../data-types.html">supported data type mappings</a>.  Note that the
<code>STRICT</code> function property impacts the actual type.  This is described below.</p>
<h2 id="naming"><a class="header" href="#naming">Naming</a></h2>
<p>The basic rules for naming are:</p>
<ol>
<li>Argument names are case-sensitive.</li>
<li>Argument names must also be valid Rust identifiers.  It's best to stick with lowercase ASCII in the set <code>[a-z0-9_]</code>.</li>
<li>Anonymous argument names are not supported.  Procedural Languages such as <code>sql</code> and <code>plpgsql</code> support anonymous arguments where they can be referenced as <code>$1</code>, <code>$2</code>, etc.  PL/Rust does not.</li>
</ol>
<h2 id="argument-ownership"><a class="header" href="#argument-ownership">Argument Ownership</a></h2>
<p>Except in the case of SQL the <code>TEXT/VARCHAR</code> and <code>BYTEA</code> types, all argument datums are passed to the PL/Rust function
as owned, immutable instances.</p>
<h2 id="quick-code-example"><a class="header" href="#quick-code-example">Quick Code Example</a></h2>
<p>Given a <code>LANGUAGE plrust</code> function like this:</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION lots_of_args(a TEXT, b INT, c BOOL[], d JSON) RETURNS INT STRICT LANGUAGE plrust AS $$
   // ... code goes here ...
$$;
</code></pre>
<p>PL/Rust essentially generates a wrapper Rust function like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pgrx::prelude::*;

fn lots_of_args(a: &amp;str, b: i32, c: Vec&lt;Option&lt;bool&gt;&gt;, d: Json) -&gt; Result&lt;Option&lt;i32&gt;, Box&lt;dyn std::error::Error + Send + Sync + 'static&gt;&gt; {
    // ... code goes here ...
}
<span class="boring">}</span></code></pre></pre>
<p>It is the developer's responsibility to fully implement this function, including <a href="functions/return-type.html">returning the proper value</a>.<br />
Note that the above is just an abridged example.  The <a href="functions/anatomy.html">anatomy</a> section describes in detail what really happens.</p>
<p>The section below describes how the <code>STRICT</code> keyword impacts the actual function signature, specifically each argument type.</p>
<h2 id="strict-and-null"><a class="header" href="#strict-and-null"><code>STRICT</code> and <code>NULL</code></a></h2>
<p>PL/Rust uses Rust's <code>Option&lt;T&gt;</code> type to represent arguments that might be NULL, plus all return types.  A Postgres UDF
that is not declared as <code>STRICT</code> means that any of its arguments <em>might</em> be NULL, and PL/Rust is required to account
for this at compile time.  This means that the actual PL/Rust function argument type is context dependent.</p>
<p>As a Postgres refresher, declaring a function as <code>STRICT</code> (which is <em>not</em> the default) means that if <strong>any</strong> argument
value is <code>NULL</code> then the return value is also <code>NULL</code>.  In this case, Postgres elides calling the function.</p>
<p>This distinction allows PL/Rust to optimize a bit.  <code>STRICT</code> functions have Rust argument types of <code>T</code> whereas non-<code>STRICT</code>
functions have argument types of <code>Option&lt;T&gt;</code>.</p>
<p>Here is the "same" function, the first declared as <code>STRICT</code>, the second not:</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION lcase(s TEXT) RETURNS TEXT STRICT LANGUAGE plrust AS $$
    let lcase = s.to_lowercase();   // `s` is a `&amp;str`
    Ok(Some(lcase)) 
$$;

# SELECT lcase('HELLO WORLD'), lcase(NULL) IS NULL AS is_null;
    lcase    | is_null 
-------------+---------
 hello world | t

</code></pre>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION lcase(s TEXT) RETURNS TEXT LANGUAGE plrust AS $$
    let unwrapped_s = s.unwrap();     // `s` is an `Option&lt;&amp;str&gt;` and will panic if `s` IS NULL
    let lcase = unwrapped_s.to_lowercase();
    Ok(Some(lcase)) 
$$;

# SELECT lcase('HELLO WORLD'), lcase(NULL) IS NULL AS is_null;
ERROR:  called `Option::unwrap()` on a `None` value
</code></pre>
<p>Rust programmers likely recognize this error message.  When a function is not declared as <code>STRICT</code>, it is the programmer's
responsibility to properly handle the possibility of an argument being <code>Option::None</code>.</p>
<h2 id="strict-is-an-immutable-property"><a class="header" href="#strict-is-an-immutable-property"><code>STRICT</code> is an Immutable Property</a></h2>
<p>PL/Rust requires that a <code>LANGUAGE plrust</code> function's <code>STRICT</code> property be immutable.  As such, PL/Rust prohibits
ALTERing the <code>STRICT</code> property:</p>
<pre><code class="language-sql">ALTER FUNCTION lcase STRICT;
ERROR:  plrust functions cannot have their STRICT property altered
DETAIL:  Use 'CREATE OR REPLACE FUNCTION' to alter the STRICT-ness of an existing plrust function
</code></pre>
<p>Instead, you must <code>CREATE OR REPLACE</code> the function.  The reason for this is that the underlying Rust wrapper function's
signature will be different and this will require that the code be changed to account for the new argument type
(<code>Option&lt;T&gt;</code> or <code>T</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="return-type"><a class="header" href="#return-type">Return Type</a></h1>
<p>Every <code>LANUAGE plrust</code> function has the same general return type, which is:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; Result&lt;
        Option&lt;T&gt;, 
        Box&lt;dyn std::error::Error + Send + Sync + 'static&gt;
&gt; {
    
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>T</code> is determined by the mapping from the declared SQL type during <code>CREATE FUNCTION</code>, and the rest is essentially
boilerplate to allow easy handling of Rust <code>Result</code>s and the SQL concept of NULL.</p>
<h2 id="why-optiont"><a class="header" href="#why-optiont">Why <code>Option&lt;T&gt;</code>?</a></h2>
<p>Any PostgreSQL procedural language function can return NULL.  PL/Rust understands and represents SQL NULL as <code>Option::None</code>.
It may seem cumbersome, but PL/Rust function must return an <code>Option&lt;T&gt;</code>, as either <code>Some(T)</code> (non-null value) or <code>None</code> (NULL value).</p>
<p>While PostgreSQL's <code>STRICT</code> function property can influence the return value such that "any NULL argument guarantees a
NULL return", Postgres does not have a way to express that a function "will never return NULL".  As such, PL/Rust
functions have the opportunity to return NULL built into their underlying function signature.</p>
<p>If a PL/Rust function would never return NULL, always return the <code>Some</code> variant.</p>
<h2 id="why-result-boxdyn-stderrorerror--send--sync--static"><a class="header" href="#why-result-boxdyn-stderrorerror--send--sync--static">Why <code>Result&lt;..., Box&lt;dyn std::error::Error + Send + Sync + 'static&gt;&gt;</code>?</a></h2>
<p>Generally speaking, Postgres procedural language functions, and even Postgres internals, can be considered "fail fast"
in that they tend to raise an error/exception at the exact point when it happens.  Rust tends towards propagating errors
up the stack, relying on the caller to handle it.</p>
<p>PL/Rust bridges this gap by requiring all <code>LANGUAGE plrust</code> functions to return a <code>Result</code>, and PL/Rust itself will
interpret the return value from the function and report a <code>Result::Err(e)</code> as a Postgres <code>ERROR</code>, aborting the current
transaction.</p>
<p>Returning a <code>Result</code> helps to simplify error handling, especially when a <code>LANGUAGE plrust</code> function uses <a href="functions/../spi.html">Spi</a>
as the Rust <code>?</code> operator is usable to propagate errors during function execution.</p>
<p>Since the  Rust "Error" type cannot be expressed as part of the <code>CREATE FUNCTION</code> statement, PL/Rust generalizes the
error to <code>Box&lt;dyn std::error::Error + Send + Sync + 'static&gt;</code> to provide as much compatability as possible with the
wide range of concrete Error types in the Rust ecosystem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set-returning-functions"><a class="header" href="#set-returning-functions">Set Returning Functions</a></h1>
<p>PL/Rust supports both set returning function styles, <code>RETURNS SETOF $type</code> and <code>RETURNS TABLE (...)</code>.  In both cases,
the function returns a specialized <code>Iterator</code> for the specific style.</p>
<p>It's useful to think of set returning functions as returning something that resembles a table, either with one unnamed
column (<code>RETURNS SETOF</code>) or multiple, named columns (<code>RETURNS TABLE</code>).</p>
<p>In both cases, the Iterator Item type is an <code>Option&lt;T&gt;</code>, where <code>T</code> is the <a href="functions/return-type.html">return type</a>.  The reason
for this is that PL/Rust needs to allow a returned row/tuple to be NULL (<code>Option::None</code>).</p>
<h2 id="returns-setof-type"><a class="header" href="#returns-setof-type"><code>RETURNS SETOF $type</code></a></h2>
<p><code>RETURNS SETOF $type</code> returns a "table" with one, unnamed column.  Each returned row must be an <code>Option</code> of the return
type, either <code>Some(T)</code> or <code>None</code>, indicating NULL.</p>
<p>A simple example of splitting a text string on whitespace, following Rust's rules:</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION split_whitespace(s text) RETURNS SETOF text STRICT LANGUAGE plrust AS $$
    let by_whitespace = s.split_whitespace();   // borrows from `s` which is a `&amp;str`
    let mapped = by_whitespace.map(|token| {
        if token == "this" { None }     // just to demonstrate returning a NULL 
        else { Some(token.to_string()) }
    });
    let iter = SetOfIterator::new(mapped);
    Ok(Some(iter)) 
$$;
</code></pre>
<p>PL/Rust generates the following method signature for the above function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn plrust_fn_oid_19691_336344&lt;'a&gt;(
    s: &amp;'a str,
) -&gt; ::std::result::Result&lt; // the function itself can return a `Result::Err`
    Option&lt; // `Option::None` will return zero rows
        ::pgrx::iter::SetOfIterator&lt; // indicates returning a set of values
            'a, // allows borrowing from `s` 
            Option&lt;String&gt;  // and the type is an optional, owned string
        &gt; 
    &gt;,
    Box&lt;dyn std::error::Error + Send + Sync + 'static&gt;, // boilerplate error type
&gt; {
   //  &lt;your code here&gt;
}
<span class="boring">}</span></code></pre></pre>
<p>And finally, its result:</p>
<pre><code class="language-sql">SELECT * FROM split_whitespace('hello world, this is a plrust set returning function');
split_whitespace 
------------------
 hello
 world,
             -- remember we returned `None` for the token "this" 
 is
 a
 plrust
 set
 returning
 function
 (9 rows)
</code></pre>
<h2 id="returns-table-"><a class="header" href="#returns-table-"><code>RETURNS TABLE (...)</code></a></h2>
<p>Returning a table with multiple named (and typed) columns is similar to returning a set.  Instead of <code>SetOfIterator</code>,
PL/Rust uses <code>TableIterator</code>.  <code>TableIterator</code> is a Rust <code>Iterator</code> whose Item is a tuple where its field types match
those of the UDF being created:</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION count_words(s text) RETURNS TABLE (count int, word text) STRICT LANGUAGE plrust AS $$
    use std::collections::HashMap;
    let mut buckets: HashMap&lt;&amp;str, i32&gt; = Default::default();
    
    for word in s.split_whitespace() {
        buckets.entry(word).and_modify(|cnt| *cnt += 1).or_insert(1);
    }
    
    let as_tuples = buckets.into_iter().map(|(word, cnt)| {
        ( Some(cnt), Some(word.to_string()) )
    }); 
    Ok(Some(TableIterator::new(as_tuples)))
$$;
</code></pre>
<p>PL/Rust generates this function signature:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn plrust_fn_oid_19691_336349&lt;'a&gt;(
   s: &amp;'a str,
) -&gt; ::std::result::Result::&lt; // the function itself can return a `Result::Err`
   Option&lt; // `Option::None` will return zero rows
       ::pgrx::iter::TableIterator&lt; // indicates returning a "table" of tuples
           'a,  // allows borrowing from `s`
           (    // a Rust tuple
               ::pgrx::name!(count, Option &lt; i32 &gt;),    // the "count" column, can be "NULL" with `Option::None`
               ::pgrx::name!(word, Option &lt; String &gt;),  // the "word" column, can be "NULL" with `Option::None`
           ),
       &gt;,
   &gt;,
   Box&lt;dyn std::error::Error + Send + Sync + 'static&gt;,
&gt; {
    // &lt;your code here&gt;
}
<span class="boring">}</span></code></pre></pre>
<p>And the results from this function are:</p>
<pre><code class="language-sql"># SELECT * FROM count_words('this is a test that is testing plrust''s SRF support');
 count |   word   
-------+----------
     1 | a
     1 | test
     1 | that
     2 | is
     1 | this
     1 | testing
     1 | SRF
     1 | support
     1 | plrust's
(9 rows)
</code></pre>
<p>The important thing to keep in mind when writing PL/Rust functions that <code>RETURNS TABLE</code> is that the structure being
returned is a Rust tuple of <code>Option&lt;T&gt;</code>s where each field's <code>T</code> is the <a href="functions/return-type.html">return type</a> as specified in
the <code>RETURNS TABLE (...)</code> clause.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-types"><a class="header" href="#data-types">Data types</a></h1>
<p>PL/Rust provides mappings for many of the built-in PostgreSQL data types.  Rust's ownership rules means that these
mappings may be different based on their usage.  Where it can PL/Rust borrows (zero-copy) arguments and returns
owned values.</p>
<div class="table-wrapper"><table><thead><tr><th>SQL</th><th>PL/Rust Argument</th><th>PL/Rust Return Type</th></tr></thead><tbody>
<tr><td><code>NULL</code></td><td><code>Option::None</code></td><td><code>Option::None</code></td></tr>
<tr><td><code>"char"</code></td><td><code>i8</code></td><td><code>i8</code></td></tr>
<tr><td><code>bigint</code></td><td><code>i64</code></td><td><code>i64</code></td></tr>
<tr><td><code>bool</code></td><td><code>bool</code></td><td><code>bool</code></td></tr>
<tr><td><code>box</code></td><td><code>BOX</code><sup>1</sup></td><td><code>BOX</code></td></tr>
<tr><td><code>bytea</code></td><td><code>&amp;[u8]</code></td><td><code>Vec&lt;u8&gt;</code></td></tr>
<tr><td><code>cstring</code></td><td><code>&amp;CStr</code></td><td><code>CString</code></td></tr>
<tr><td><code>date</code></td><td><code>Date</code></td><td><code>Date</code></td></tr>
<tr><td><code>daterange</code></td><td><code>Range&lt;Date&gt;</code></td><td><code>Range&lt;Date&gt;</code></td></tr>
<tr><td><code>double precision</code></td><td><code>f64</code></td><td><code>f64</code></td></tr>
<tr><td><code>int4range</code></td><td><code>Range&lt;i32&gt;</code></td><td><code>Range&lt;i32&gt;</code></td></tr>
<tr><td><code>int8range</code></td><td><code>Range&lt;i64&gt;</code></td><td><code>Range&lt;i64&gt;</code></td></tr>
<tr><td><code>integer</code></td><td><code>i32</code></td><td><code>i32</code></td></tr>
<tr><td><code>interval</code></td><td><code>Interval</code></td><td><code>Interval</code></td></tr>
<tr><td><code>json</code></td><td><code>Json(serde_json::Value)</code></td><td><code>Json(serde_json::Value)</code></td></tr>
<tr><td><code>jsonb</code></td><td><code>JsonB(serde_json::Value)</code></td><td><code>JsonB(serde_json::Value)</code></td></tr>
<tr><td><code>numeric</code></td><td><code>AnyNumeric</code></td><td><code>AnyNumeric</code></td></tr>
<tr><td><code>numrange</code></td><td><code>Range&lt;AnyNumeric&gt;</code></td><td><code>Range&lt;AnyNumeric&gt;</code></td></tr>
<tr><td><code>oid</code></td><td><code>Oid</code></td><td><code>Oid</code></td></tr>
<tr><td><code>point</code></td><td><code>Point</code></td><td><code>Point</code></td></tr>
<tr><td><code>real</code></td><td><code>f32</code></td><td><code>f32</code></td></tr>
<tr><td><code>smallint</code></td><td><code>i16</code></td><td><code>i16</code></td></tr>
<tr><td><code>text</code></td><td><code>&amp;str</code></td><td><code>String</code></td></tr>
<tr><td><code>tid</code></td><td><code>ItemPointerData</code></td><td><code>ItemPointerData</code></td></tr>
<tr><td><code>time with time zone</code></td><td><code>TimeWithTimeZone</code></td><td><code>TimeWithTimeZone</code></td></tr>
<tr><td><code>time</code></td><td><code>Time</code></td><td><code>Time</code></td></tr>
<tr><td><code>timestamp with time zone</code></td><td><code>TimestampWithTimeZone</code></td><td><code>TimestampWithTimeZone</code></td></tr>
<tr><td><code>timestamp</code></td><td><code>Timestamp</code></td><td><code>Timestamp</code></td></tr>
<tr><td><code>tsrange</code></td><td><code>Range&lt;Timestamp&gt;</code></td><td><code>Range&lt;Timestamp&gt;</code></td></tr>
<tr><td><code>tstzrange</code></td><td><code>Range&lt;TimestampWithTimeZone&gt;</code></td><td><code>Range&lt;TimestampWithTimeZone&gt;</code></td></tr>
<tr><td><code>uuid</code></td><td><code>Uuid</code></td><td><code>Uuid</code></td></tr>
<tr><td><code>varchar</code></td><td><code>&amp;str</code></td><td><code>String</code></td></tr>
<tr><td><code>void</code></td><td>n/a</td><td><code>()</code></td></tr>
</tbody></table>
</div>
<p><sup>1: This is Postgres' geometric BOX type, not to be confused with Rust's <code>Box</code> type, which stores allocated data on the heap</sup></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="no-unsigned-types"><a class="header" href="#no-unsigned-types">No Unsigned Types</a></h1>
<p>Rust programmers may be asking "where are the unsigned types like <code>u32</code>?".  PostgreSQL does not have unsigned integer types.
As such, neither does PL/Rust.</p>
<p>In order to represent a value larger than <code>i32::MAX</code>, <code>BIGINT</code> is the proper SQL type.  To represent a value larger than
<code>i64::MAX</code>, use the <code>NUMERIC</code> type.  Postgres also has no concept of an <code>isize</code> or <code>usize</code>, so these have no
corresponding SQL mapping.</p>
<p>PL/Rust's <code>AnyNumeric</code> type has <code>From</code> and <code>TryFrom</code> implementations for all of Rust's primitive types (plus strings).
This makes it fairly straightforward to up-convert a Rust primitive into a SQL <code>NUMERIC</code>:</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION upconvert_bigint(i BIGINT) RETURNS NUMERIC STRICT LANGUAGE plrust AS $$
    let n: AnyNumeric = i.into();   // `i` is an `i64`, lets convert to `AnyNumeric`
    Ok(Some(n + 1))    
$$;

# SELECT upconvert_bigint(9223372036854775807);
upconvert_bigint   
---------------------
 9223372036854775808
(1 row)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays"><a class="header" href="#arrays">Arrays</a></h1>
<p>Arrays of all of supported types are mapped as <code>Array&lt;T&gt;</code> where <code>T</code> is the Rust mapping for the
SQL datatype.  For example, a SQL <code>BIGINT[]</code> is mapped to <code>Array&lt;i64&gt;</code>, and a <code>TEXT[]</code> is mapped to
<code>Array&lt;&amp;str&gt;</code>.</p>
<p>Working with arrays can be <em>slightly</em> cumbersome as Postgres allows NULL as an individual array element.  As Rust has
no concept of "null", PL/Rust uses <code>Option&lt;T&gt;</code> to represent the SQL idea of "I don't have a value".</p>
<pre><code class="language-sql">CREATE FUNCTION sum_array(a INT[]) RETURNS BIGINT STRICT LANGUAGE plrust AS $$
    let sum = a.into_iter().map(|i| i.unwrap_or_default() as i64).sum();
    Ok(Some(sum))
$$;

# SELECT sum_array(ARRAY[1,2,3]::int[]);
 sum_array 
-----------
         6
</code></pre>
<h2 id="iteration-and-slices"><a class="header" href="#iteration-and-slices">Iteration and Slices</a></h2>
<p>Pl/Rust Arrays support slices over the backing Array data if it's an array of a primitive type (i8/16/32/64, f32/64).
This can provide drastic performance improvements and even help lead to the Rust compiler autovectorizing code.</p>
<p>Let's examine this using arrays of random <code>FLOAT4</code> values:</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION random_floats(many int) RETURNS float4[] STRICT PARALLEL SAFE LANGUAGE sql AS $$
    SELECT array_agg(random()) FROM generate_series(1, many)
$$;

CREATE TABLE floats AS SELECT random_floats(1000) f FROM generate_series(1, 100000);
</code></pre>
<p>Next, we'll sum the array using a function similar to the above:</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION sum_array(a float4[]) RETURNS float4 STRICT LANGUAGE plrust AS $$
    let sum = a.into_iter().map(|i| i.unwrap_or_default()).sum();
    Ok(Some(sum))
$$;

# explain analyze select sum_array(f) from floats;
QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Seq Scan on floats  (cost=0.00..23161.32 rows=86632 width=4) (actual time=0.064..981.105 rows=100000 loops=1)
 Planning Time: 0.037 ms
 Execution Time: 983.753 ms
</code></pre>
<p>Since in this case we know that the input array won't contain null values, we can optimize slightly.  This does a fast
"O(1)" check for NULLs when creating the iterator, rather than checking each individual element during iteration:</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION sum_array_no_nulls(a float4[]) RETURNS float4 STRICT LANGUAGE plrust AS $$
    let sum = a.iter_deny_null().sum();
    Ok(Some(sum))
$$;

explain analyze select sum_array_no_nulls(f) from floats;
QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Seq Scan on floats  (cost=0.00..26637.00 rows=100000 width=4) (actual time=0.055..672.365 rows=100000 loops=1)
 Planning Time: 0.035 ms
 Execution Time: 676.243 ms
</code></pre>
<p>Next, lets take a look at converting the input array into a slice before summing the values.  This is particularly fast
as it's a true "zero copy" operation:</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION sum_array_slice(a float4[]) RETURNS float4 STRICT LANGUAGE plrust AS $$
    let slice = a.as_slice()?;  // use the `?` operator as not all `Array&lt;T&gt;`s can be converted into a slice
    let sum = slice.iter().sum();
    Ok(Some(sum))
$$;

explain analyze select sum_array_slice(f) from floats;
QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Seq Scan on floats  (cost=0.00..26637.00 rows=100000 width=4) (actual time=0.055..478.635 rows=100000 loops=1)
 Planning Time: 0.036 ms
 Execution Time: 482.344 ms
</code></pre>
<p>Finally, lets do some magic to coax the Rust compiler into autovectorizing our "sum_array" function.  The code for this
comes from, interestingly enough, Stack Overflow:  https://stackoverflow.com/questions/23100534/how-to-sum-the-values-in-an-array-slice-or-vec-in-rust/67191480#67191480</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION sum_array_simd(a float4[]) RETURNS float4 STRICT LANGUAGE plrust AS $$
    use std::convert::TryInto;
    
    const LANES: usize = 16;
    
    pub fn simd_sum(values: &amp;[f32]) -&gt; f32 {
        let chunks = values.chunks_exact(LANES);
        let remainder = chunks.remainder();
    
        let sum = chunks.fold([0.0f32; LANES], |mut acc, chunk| {
            let chunk: [f32; LANES] = chunk.try_into().unwrap();
            for i in 0..LANES {
                acc[i] += chunk[i];
            }
            acc
        });
    
        let remainder: f32 = remainder.iter().copied().sum();
    
        let mut reduced = 0.0f32;
        for i in 0..LANES {
            reduced += sum[i];
        }
        reduced + remainder
    }

    let slice = a.as_slice()?;
    let sum = simd_sum(slice);
    Ok(Some(sum))
$$;


explain analyze select sum_array_simd(f) from floats;
QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Seq Scan on floats  (cost=0.00..26637.00 rows=100000 width=4) (actual time=0.054..413.702 rows=100000 loops=1)
 Planning Time: 0.038 ms
 Execution Time: 417.237 ms
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-defined-types"><a class="header" href="#user-defined-types">User Defined Types</a></h1>
<p>PL/Rust supports using User Defined Types (UDTs; sometimes referred to as "composite types") in <code>LANGUAGE plrust</code> functions.
UDTs can be used as arguments and return types.</p>
<p>The general approach with UDTs is to first define one in SQL:</p>
<pre><code class="language-sql">CREATE TYPE person AS (
    name text,
    age  float8
);
</code></pre>
<p><code>person</code> can now be used in any PL/Rust function.  To instantiate a new <code>person</code>:</p>
<pre><code class="language-sql">create function make_person(name text, age float8) returns person
    strict parallel safe
    language plrust as
$$
    // create the Heap Tuple representation of the SQL type `person`
    let mut p = PgHeapTuple::new_composite_type("person")?;
    
    // set a few of its attributes
    //
    // Runtime errors can occur if the attribute name is invalid or if the Rust type of the value
    // is not compatible with the backing SQL type for that attribute.  Hence the use of the `?` operator
    p.set_by_name("name", name)?;
    p.set_by_name("age", age)?;
    
    // return the `person`
    Ok(Some(p))
$$;
</code></pre>
<p>Individual field accessors for the properties are straight-forward:</p>
<pre><code class="language-sql">create function get_person_name(p person) returns text
    strict parallel safe
    language plrust as
$$
   // `p` is a `PgHeapTuple` over the underlying data for `person`
   Ok(p.get_by_name("name")?)
$$;

create function get_person_age(p person) returns float8
    strict parallel safe
    language plrust as
$$
   // `p` is a `PgHeapTuple` over the underlying data for `person`
   Ok(p.get_by_name("age")?)
$$;
</code></pre>
<p>A generic accessor, for example, requires encoding knowledge of the UDT structure, but provides quite a bit of flexibility.</p>
<p>Note that this function <code>returns text</code>.  This is a common denominator type to represent the various attribute types used
by <code>person</code>.  Fortunately, Postgres and PL/Rust have fantastic support for converting values to text/Strings:</p>
<pre><code class="language-sql">create function get_person_attribute(p person, attname text) returns text
    strict parallel safe
    language plrust as
$$
   match attname.to_lowercase().as_str() {
    "age" =&gt; {
        let age:Option&lt;f64&gt; = p.get_by_name("age")?;
        Ok(age.map(|v| v.to_string()))
    },
    "name" =&gt; {
        Ok(p.get_by_name("name")?)
    },
    _ =&gt; panic!("unknown attribute: `{attname}`")
   }
$$;
</code></pre>
<p>This lends itself nicely to creating a custom operator to extract a <code>person</code>'s named attribute.</p>
<pre><code class="language-sql">create operator -&gt;&gt; (function = get_person_attribute, leftarg = person, rightarg = text);
</code></pre>
<p>Tying these pieces together:</p>
<pre><code class="language-sql">
-- assume all of the above sql has been executed

create table people
(
    id serial8 not null primary key,
    p  person
);

insert into people (p) values (make_person('Johnny', 46.24));
insert into people (p) values (make_person('Joe', 99.09));
insert into people (p) values (make_person('Dr. Beverly Crusher of the Starship Enterprise', 32.0));

select p -&gt;&gt; 'name' as name, (p -&gt;&gt; 'age')::float8 as age from people;
                      name                      |  age  
------------------------------------------------+-------
 Johnny                                         | 46.24
 Joe                                            | 99.09
 Dr. Beverly Crusher of the Starship Enterprise |    32
(3 rows)
</code></pre>
<h2 id="discussion"><a class="header" href="#discussion">Discussion</a></h2>
<p>In Rust, <a href="https://docs.rs/plrust-trusted-pgrx/latest/plrust_trusted_pgrx/heap_tuple/struct.PgHeapTuple.html"><code>PgHeapTuple</code></a>
is the type that generically represents all UDTs.</p>
<p><code>PgHeapTuple</code> provides the ability to construct a new UDT by its SQL name.  It also provides attribute getter and setter methods
for reading and mutating attributes.</p>
<p>Attributes can be addressed by name or one-based index.  Typical errors such as specifying an attribute name that doesn't
exist, an index that is out of bounds, or a Rust type for the value that is not compatible with that attribute's SQL type
will return a <a href="https://docs.rs/plrust-trusted-pgrx/latest/plrust_trusted_pgrx/heap_tuple/enum.TryFromDatumError.html"><code>TryFromDatumError</code></a>.
An early-return that error using the <code>?</code> operator (as demonstrated in the examples above) or matching on the error are
both fine ways of handling such errors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="built-in-functions"><a class="header" href="#built-in-functions">Built-in functions</a></h1>
<p>This page documents many of the high level functions,
targeted functionality is covered on dedicated sub-sections.</p>
<ul>
<li><a href="spi.html">Server Programming Interface (SPI)</a></li>
<li><a href="triggers.html">Triggers</a></li>
<li><a href="logging.html">Logging to PostgreSQL from PL/Rust</a></li>
</ul>
<h2 id="functions-available"><a class="header" href="#functions-available">Functions available</a></h2>
<p>Functions available to PL/Rust are defined under
the <a href="https://github.com/tcdi/plrust/blob/main/trusted-pgrx/src/lib.rs"><code>trusted-pgrx</code> directory in <code>lib.rs</code></a>. User functions in <code>plrust</code> will not compile if they use
the <code>unsafe</code> keyword.
There are a handful of functions in <code>trusted-pgrx</code> that are
declared unsafe; <code>plrust</code> functions cannot use them because they would need an <code>unsafe {}</code> block.</p>
<h2 id="datum-functions"><a class="header" href="#datum-functions">Datum functions</a></h2>
<p>PL/Rust function support for various Datums are documented by
<a href="https://docs.rs/pgrx/latest/pgrx/datum/index.html">pgrx on docs.rs</a>,
the source is <a href="https://github.com/tcdi/pgrx/tree/master/pgrx/src/datum">on GitHub</a> for those interested.
There are Datums defined in <code>pgrx</code> that are not included in PL/Rust
because they have not been imported by <code>plrust</code>.</p>
<p><a href="https://docs.rs/pgrx/latest/pgrx/datum/numeric/struct.AnyNumeric.html"><code>AnyNumeric</code></a>:
A plain PostgreSQL <code>NUMERIC</code> with default precision and scale values. This is a sufficient type to represent any Rust primitive value from <code>i128::MIN</code> to <code>u128::MAX</code> and anything in between.</p>
<p><a href="https://docs.rs/pgrx/latest/pgrx/datum/trait.FromDatum.html"><code>FromDatum</code></a> and <a href="https://docs.rs/pgrx/latest/pgrx/datum/trait.IntoDatum.html"><code>IntoDatum</code></a>: Provide conversions between <code>pg_sys::Datum</code> and Rust types.</p>
<p><a href="https://docs.rs/pgrx/latest/pgrx/datum/struct.Json.html"><code>Json</code></a>
and
<a href="https://docs.rs/pgrx/latest/pgrx/datum/struct.JsonB.html"><code>JsonB</code></a>
match the types in PostgreSQL of the same name.</p>
<p><a href="https://docs.rs/pgrx/latest/pgrx/datum/struct.Date.html"><code>Date</code></a>:
A plain PostgreSQL <code>DATE</code> type without a time component.</p>
<p><code>Time</code> / <code>TimeWithTimeZone</code> / <code>Timestamp</code> / <code>TimestampWithTimeZone</code></p>
<p>Range Support In progress</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging-to-postgresql-from-plrust"><a class="header" href="#logging-to-postgresql-from-plrust">Logging to PostgreSQL from PL/Rust</a></h1>
<p>PL/Rust provides the ability to log details using PostgreSQL's logging
system.  This functionality is exposed from pgrx via
<a href="https://github.com/tcdi/plrust/blob/main/plrust-trusted-pgrx/src/lib.rs">plrust/plrust-trusted-pgrx/src/lib.rs</a>.</p>
<p>The macros available for logging are defined:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub use ::pgrx::{
    debug1, debug2, debug3, debug4, debug5, ereport, error, info, log, notice, warning,
};
<span class="boring">}</span></code></pre></pre>
<h2 id="basic-logging"><a class="header" href="#basic-logging">Basic logging</a></h2>
<p>Using the <code>log!()</code> macro will send the message defined in the function to the
PostgreSQL logs defined by your <code>postgresql.conf</code>.  Running the following
example of <code>plrust.one()</code> creates a <code>LOG</code> record.</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION plrust.one()
    RETURNS INT
    LANGUAGE plrust
AS
$$
    log!("Hello!  Friendly log message here.");
    Ok(Some(1))
$$
;
</code></pre>
<p>Running <code>plrust.one()</code> will run normally and the client running the query will
be presented with the results.  The <code>log!()</code> macro adds the defined log
message to the PostgreSQL log file.</p>
<p>The exact contents on the log line created in PostgreSQL's log file depends
on your <code>postgresql.conf</code> settings related to logging.  The following example
is what it may look like.</p>
<pre><code class="language-bash">2023-03-04 16:06:40 UTC [8109]: [15-1] user=postgres,db=plrust,app=psql,client=[local],query_id=-2211430114177040240  LOG:  Hello!  Friendly log message here.
</code></pre>
<p>The remainder of logging examples will only show the details controlled by PL/Rust
like the following example.</p>
<pre><code class="language-bash">LOG:  Hello!  Friendly log message here.
</code></pre>
<p>Logging is not limited to static messages.  Values from the function can be included
using the <code>{variable}</code> notation.  Beware of data types, the <code>i32</code> value returned
by the <code>plrust.one()</code> function needs to be converted <code>.to_string()</code> to include
in the logged message string.</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION plrust.one()
    RETURNS INT
    LANGUAGE plrust
AS
$$
    let one_val = 1_i32;
    log!("The plrust.one() function is returning: {one_val}");
    Ok(Some(one_val))
$$
;
</code></pre>
<p>When the above function runs, the resulting log line looks like the following.</p>
<pre><code>LOG:  The plrust.one() function is returning: 1
</code></pre>
<h2 id="warnings"><a class="header" href="#warnings">Warnings</a></h2>
<p>Use the <code>warning!()</code> macro to log a more severe message.
Warnings are sent to the log file as well as being returned to the client as a
<code>WARNING</code>.</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION plrust.one()
    RETURNS INT
    LANGUAGE plrust
AS
$$
    let expected_val = 1_i32;
    let one_val = 2_i32;

    if expected_val != one_val {
        warning!("The value for plrust.one() is unexpected. Found {one_val}")
    } else {
        log!("The plrust.one() function is returning: {one_val}");
    }

    Ok(Some(one_val))
$$
;
</code></pre>
<p>The following <code>WARNING</code> message is sent to the PostgreSQL log and to the client.</p>
<pre><code class="language-bash">WARNING:  The value for plrust.one() is unexpected. Found 2
</code></pre>
<p>Running the above in <code>psql</code> looks like the following example.
You can see the user is presented with the warning message as well as the results
showing the <code>one</code> function returning the value <code>2</code>.</p>
<pre><code class="language-bash">plrust=# select plrust.one();
WARNING:  The value for plrust.one() is unexpected. Found 2
DETAIL:  
 one 
-----
   2
(1 row)
</code></pre>
<h2 id="errors"><a class="header" href="#errors">Errors</a></h2>
<p>There are cases when a function simply cannot proceed and these errors need to
be logged.  The following example changes the <code>warning</code> from the previous example
to an <code>error</code>.</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION plrust.one()
    RETURNS INT
    LANGUAGE plrust
AS
$$
    let expected_val = 1_i32;
    let one_val = 2_i32;
    let one_val_str = one_val.to_string();

    if expected_val != one_val {
        error!("Invalid for plrust.one(). Found {one_val_str}")
    } else {
        log!("The plrust.one() function is returning: {one_val_str}");
    }

    Ok(Some(one_val))
$$
;
</code></pre>
<p>When PL/Rust runs the <code>error!()</code> macro the message is logged to the log file,
returned to the client, and the execution of the function is terminated with a panic.
In <code>psql</code> the user sees:</p>
<pre><code class="language-bash">plrust=# select plrust.one();
ERROR:  Invalid for plrust.one(). Found 2
DETAIL:  
plrust=# 
</code></pre>
<p>In the PostgreSQL logs the following output is recorded.  Notice the <code>panicked</code>
line prior to the <code>ERROR</code> reported by the PL/Rust function.</p>
<pre><code class="language-bash">thread '&lt;unnamed&gt;' panicked at 'Box&lt;dyn Any&gt;', /var/lib/postgresql/.cargo/registry/src/github.com-1ecc6299db9ec823/pgrx-pg-sys-0.7.2/src/submodules/panic.rs:160:13
ERROR:  Invalid for plrust.one(). Found 2
</code></pre>
<h2 id="notifying-the-user"><a class="header" href="#notifying-the-user">Notifying the user</a></h2>
<p>Using <code>notice!()</code> and <code>info!()</code> macros return the message to the client running
the query, allowing functions to provide feedback to the user running
the query.  These options do not log the message to the PostgreSQL logs.</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION plrust.one()
    RETURNS INT
    LANGUAGE plrust
AS
$$
    notice!("Hello, this is a notice");
    Ok(Some(1))
$$
;
</code></pre>
<p>Running <code>SELECT plrust.one()</code> returns the expected value of <code>1</code>
along with the defined notice. Using <code>psql</code> returns and example
like the following code block.</p>
<pre><code class="language-bash">NOTICE:  Hello, this is a notice
DETAIL:  
┌─────┐
│ one │
╞═════╡
│   1 │
└─────┘
</code></pre>
<h2 id="using-ereport"><a class="header" href="#using-ereport">Using ereport</a></h2>
<p>For the most control over logging you can use the <code>ereport!()</code> macro.
This is not necessary for most use cases.</p>
<pre><code class="language-sql">CREATE FUNCTION one()
    RETURNS INT
    LANGUAGE plrust
AS
$$
    ereport!(PgLogLevel::LOG,
        PgSqlErrorCode::ERRCODE_SUCCESSFUL_COMPLETION,
        "A user ran the one() function");
    Ok(Some(1))
$$
;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="triggers"><a class="header" href="#triggers">Triggers</a></h1>
<p>PL/Rust functions can be used to define trigger functions on data changes.
A trigger function is created using the <code>CREATE FUNCTION</code> command, declaring it as a function with no arguments and a return type of
<code>trigger</code>. Trigger variables are available from in <code>trigger</code>
to describe the condition that triggered the call and the <code>new</code> and <code>old</code>
rows.</p>
<p>PL/Rust trigger support options are <a href="https://docs.rs/pgrx/latest/pgrx/prelude/struct.PgTrigger.html">documented on docs.rs</a> and defined in the <code>.rs</code> files in the
<a href="https://github.com/tcdi/pgrx/tree/master/pgrx/src/trigger_support">trigger_support</a> directory.</p>
<p>These examples are an expansion of the code from <a href="https://github.com/tcdi/plrust/blob/main/plrust/src/tests.rs"><code>plrust/plrust/src/tests.rs</code></a>. The elaborations here
illustrate additional functionality.</p>
<h2 id="table-for-triggers"><a class="header" href="#table-for-triggers">Table for Triggers</a></h2>
<p>Create the <code>plrust.dog</code> table to allow us to keep track of our dogs, and how much attention
they have received via a count of <code>scritches</code>.</p>
<pre><code class="language-sql">CREATE TABLE plrust.dog (
    id BIGINT NOT NULL GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    name TEXT,
    scritches INT NOT NULL DEFAULT 0,
    last_scritch TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
</code></pre>
<p>The <code>name</code> column in <code>plrust.dog</code> is the only column without a default
value set.  The <code>scritches</code> and <code>last_scritch</code> column both have defaults set.
The goal of this design is to only have to define the <code>name</code> during <code>INSERT</code>.
Subsequent <code>UPDATE</code> queries should only have to update the
<code>last_scritch</code> column.</p>
<h2 id="trigger-example"><a class="header" href="#trigger-example">Trigger example</a></h2>
<p>The following example creates a trigger function named <code>plrust.dog_trigger()</code>.
The trigger will be used on <code>INSERT</code> and <code>UPDATE</code> with slightly different
behavior depending on which operation is being used. This logic is based
on the value of <code>trigger.op()?</code>, for <code>INSERT</code> the <code>trigger.new</code> object is used,
for <code>UPDATE</code> the <code>trigger.old</code> object is used.
This code is explained further after the code block.</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION plrust.dog_trigger()
RETURNS trigger AS
$$
    let tg_op = trigger.op()?;

    let my_row = match tg_op {
        INSERT =&gt; trigger.new().unwrap(),
        _ =&gt; trigger.old().unwrap()
    };
    let mut my_row = my_row.into_owned();

    let counter_field = "scritches";
    match my_row.get_by_name::&lt;i32&gt;(counter_field)? {
        Some(val) =&gt; my_row.set_by_name(counter_field, val + 1)?,
        None =&gt; (),
    }

    Ok(Some(my_row))
$$
LANGUAGE plrust;


CREATE TRIGGER dog_trigger
    BEFORE INSERT OR UPDATE ON plrust.dog
    FOR EACH ROW
    EXECUTE FUNCTION plrust.dog_trigger();
</code></pre>
<p>The <code>tg_op</code> variable is available from the <code>trigger.op()</code> method and has values
of <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> and <code>TRUNCATE</code>.  See the definition
of <a href="https://docs.rs/pgrx/latest/pgrx/prelude/enum.PgTriggerOperation.html"><code>PgTriggerOperation</code> for more</a>.
The <code>tg_op</code> value is used in a <code>match</code> to define the <code>my_row</code> variable.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tg_op = trigger.op()?;

let my_row = match tg_op {
    INSERT =&gt; trigger.new().unwrap(),
    _ =&gt; trigger.old().unwrap()
};
let mut my_row = my_row.into_owned();
<span class="boring">}</span></code></pre></pre>
<p>With the appropriate <code>my_row</code> identified, the next step is to increment the
<code>scritches</code> column by 1.  This is defined in the <code>counter_field</code> variable
for easy reuse. The <code>get_by_name</code> and <code>set_by_name</code> functions are used for
this operation.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let counter_field = "scritches";
match my_row.get_by_name::&lt;i32&gt;(counter_field)? {
    Some(val) =&gt; my_row.set_by_name(counter_field, val + 1)?,
    None =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<p>Finally, the <code>my_row</code> is returned for the operation to proceed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Ok(Some(my_row))
<span class="boring">}</span></code></pre></pre>
<p>Next we <code>INSERT</code> a row and then query the table to observe the effects of the trigger.</p>
<pre><code class="language-sql">INSERT INTO plrust.dog (name) VALUES ('Nami');
SELECT * FROM plrust.dog;
</code></pre>
<p>The results show that while the <code>DEFAULT</code> value for the <code>scritches</code> column is
defined as <code>0</code> in the table, the initial value is 1 because trigger updated
the value.</p>
<pre><code class="language-bash"> id | name | scritches |         last_scritch          
----+------+-----------+-------------------------------
  1 | Nami |         1 | 2023-03-04 17:30:43.601525+00
</code></pre>
<p>If we update the record for Nami by setting the <code>last_scritch</code> value to <code>NOW()</code>
the trigger will increment the <code>scritches</code> column value for us.</p>
<pre><code class="language-sql">UPDATE plrust.dog
    SET last_scritch = NOW()
    WHERE id = 1;

SELECT * FROM plrust.dog;
</code></pre>
<pre><code> id | name | scritches |         last_scritch          
----+------+-----------+-------------------------------
  1 | Nami |         2 | 2023-03-04 17:35:05.320482+00
</code></pre>
<h2 id="not-yet-supported"><a class="header" href="#not-yet-supported">Not yet supported</a></h2>
<p>Event Triggers and <code>DO</code> blocks are not (yet) supported by PL/Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="server-programming-interface-spi"><a class="header" href="#server-programming-interface-spi">Server Programming Interface (SPI)</a></h1>
<p>PL/Rust provides support for PostgreSQL's <a href="https://www.postgresql.org/docs/current/spi.html">SPI</a>.</p>
<p><code>Error</code></p>
<p><code>Result</code></p>
<p><code>Spi</code></p>
<h2 id="example-usage"><a class="header" href="#example-usage">Example usage</a></h2>
<p>The following function uses <code>SPI</code> to create a PostgreSQL
<a href="https://www.postgresql.org/docs/current/functions-srf.html">Set Returning Function</a> (SRF).</p>
<pre><code class="language-sql">CREATE FUNCTION spi_srf()
    RETURNS SETOF BIGINT
    LANGUAGE plrust
AS
$$
    let query = "SELECT id::BIGINT FROM generate_series(1, 3) id;";

    Spi::connect(|client| {
        let mut results = Vec::new();
        let mut tup_table = client.select(query, None, None)?;

        while let Some(row) = tup_table.next() {
            let id = row["id"].value::&lt;i64&gt;()?;
            results.push(id);
        }
        Ok(Some(SetOfIterator::new(results)))
    })

$$;
</code></pre>
<h2 id="complex-return-types"><a class="header" href="#complex-return-types">Complex return types</a></h2>
<p>PL/Rust currently <a href="https://github.com/tcdi/plrust/issues/36">does not support <code>RETURNS TABLE</code></a> or
<a href="https://github.com/tcdi/plrust/issues/200#issuecomment-1426880622">complex types with <code>RETURNS SETOF</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-function-calling"><a class="header" href="#dynamic-function-calling">Dynamic Function Calling</a></h1>
<p>PL/Rust provides the ability to dynamically call any function (callable to the current user) directly from a Rust
function.  These functions can be in <em>any</em> language, including <code>sql</code>, <code>plpgsql</code>, <code>plrust</code>, <code>plperl</code>, etc.</p>
<p>The call interface is dynamic in that the callee is resolved at runtime and its argument and return types are also
checked at runtime.  While this does introduce a small bit of overhead, it's significantly less than doing
what might be the equivalent operation via Spi.</p>
<p>The ability to dynamically call functions enables users to write functions in the language that makes the most sense
for the operation being performed.  In many cases, a <code>LANGUAGE plpgsql</code> function is exactly what's needed, and a
<code>LANGUAGE plrust</code> function can now use its result to execute further, possibly CPU-intensive, work.</p>
<h2 id="important-rust-types"><a class="header" href="#important-rust-types">Important Rust Types</a></h2>
<p>This dynamic calling interface introduces two new types that are used to facilitate dynamically calling functions:
<code>Arg</code> and <code>FnCallError</code>.</p>
<h3 id="arg"><a class="header" href="#arg"><code>Arg</code></a></h3>
<p><code>Arg</code> describes the style of a user-provided function argument.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The kinds of [`fn_call`] arguments.  
pub enum Arg&lt;T&gt; {
    /// The argument value is a SQL NULL
    Null,

    /// The argument's `DEFAULT` value should be used
    Default,

    /// Use this actual value
    Value(T),
}
<span class="boring">}</span></code></pre></pre>
<p>Rust doesn't exactly have the concept of "NULL" nor does it have direct support for overloaded functions.  This is where
the <code>Null</code> and <code>Default</code> variants come in.</p>
<p>There's a sealed trait that corresponds to this enum named <code>FnCallArg</code>.  It is not a trait that users needs to implement,
but is used by PL/Rust to dynamically represent a set of heterogeneous argument types.</p>
<h3 id="fncallerror"><a class="header" href="#fncallerror"><code>FnCallError</code></a></h3>
<p>There's also a set of runtime error conditions if function resolution fails.  These are recoverable errors in that user
code could <code>match</code> on the return value and potentially make different decisions, or just raise a panic with the error to
immediately abort the current transaction.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// [`FnCallError`]s represent the set of conditions that could case [`fn_call()`] to fail in a
/// user-recoverable manner.
#[derive(thiserror::Error, Debug, Clone, Eq, PartialEq)]
pub enum FnCallError {
    #[error("Invalid identifier: `{0}`")]
    InvalidIdentifier(String),

    #[error("The specified function does not exist")]
    UndefinedFunction,

    #[error("The specified function exists, but has overloaded versions which are ambiguous given the argument types provided")]
    AmbiguousFunction,

    #[error("Can only dynamically call plain functions")]
    UnsupportedFunctionType,

    #[error("Functions with OUT/IN_OUT/TABLE arguments are not supported")]
    UnsupportedArgumentModes,

    #[error("Functions with argument or return types of `internal` are not supported")]
    InternalTypeNotSupported,

    #[error("The requested return type `{0}` is not compatible with the actual return type `{1}`")]
    IncompatibleReturnType(pg_sys::Oid, pg_sys::Oid),

    #[error("Function call has more arguments than are supported")]
    TooManyArguments,

    #[error("Did not provide enough non-default arguments")]
    NotEnoughArguments,

    #[error("Function has no default arguments")]
    NoDefaultArguments,

    #[error("Argument #{0} does not have a DEFAULT value")]
    NotDefaultArgument(usize),

    #[error("Argument's default value is not a constant expression")]
    DefaultNotConstantExpression,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="calling-a-function"><a class="header" href="#calling-a-function">Calling a Function</a></h2>
<p>The top-level function <code>fn_call()</code> is what is used to dynamically call a function.  Its signature is:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn fn_call&lt;R: FromDatum + IntoDatum&gt;(
    fname: &amp;str,
    args: &amp;[&amp;dyn FnCallArg],
) -&gt; Result&lt;Option&lt;R&gt;, FnCallError&gt;
<span class="boring">}</span></code></pre></pre>
<p><code>fn_call</code> itself takes two arguments.  The first, <code>fname</code> is the (possibly schema-qualified) function name, as a string.</p>
<p>The second argument, <code>args</code>, is a slice of <code>FnCallArg</code> dyn references (these are written using <code>&amp;Arg::XXX</code>).  And it
returns a <code>Result&lt;Option&lt;R&gt;, FnCallError&gt;</code>.</p>
<p>An <code>Ok</code> response will either contain <code>Some(R)</code> if the called function returned a non-null value, or <code>None</code> if it did.</p>
<p>An <code>Err</code> response will contain one of the <code>FnCallError</code> variants detailed above, indicating the problem encountered
while trying to call the function.  It is guaranteed that if <code>fn_call</code> returns an <code>Err</code>, then the desired function was
<strong>not</strong> called.</p>
<p>If the called function raises a Postgres <code>ERROR</code> then the current transaction is aborted and control is returned back
to Postgres, not the caller.  This is typical Postgres and PL/Rust behavior in the face of an <code>ERROR</code> or Rust panic.</p>
<h2 id="simple-example"><a class="header" href="#simple-example">Simple Example</a></h2>
<p>First, define a SQL function that sums the elements of an <code>int[]</code>.  We're using a <code>LANGUAGE sql</code> function here
to demonstrate how PL/Rust can call functions of any other language:</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION sum_array(a int[]) RETURNS int STRICT LANGUAGE sql AS $$ SELECT sum(e) FROM unnest(a) e $$;
</code></pre>
<p>Now, call this function from a PL/Rust function:</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION transform_array(a int[]) RETURNS int STRICT LANGUAGE plrust AS $$
    let a = a.into_iter().map(|e| e.unwrap_or(0) + 1).collect::&lt;Vec&lt;_&gt;&gt;();  // add one to every element of the array
    Ok(fn_call("sum_array", &amp;[&amp;Arg::Value(a)])?)
$$;

SELECT transform_array(ARRAY[1,2,3]);
transform_array 
-----------------
               9
(1 row)
</code></pre>
<h2 id="complex-example"><a class="header" href="#complex-example">Complex Example</a></h2>
<p>This is contrived, of course, but let's make a PL/Rust function with a few different argument types and have it simply
convert their values to a debug-formatted String.  Then we'll call that function from another PL/Rust function.</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION debug_format_args(a text, b bigint, c float4 DEFAULT 0.99) RETURNS text LANGUAGE plrust AS $$
    Ok(Some(format!("{:?}, {:?}, {:?}", a, b, c)))  
$$;

SELECT debug_format_args('hi', NULL);
      debug_format_args       
------------------------------
 Some("hi"), None, Some(0.99)
(1 row)
</code></pre>
<p>Now, call it from another PL/Rust function using these same argument values.  Which is <code>'hi'</code> for the first argument,
NULL for the second, and using the default value for the third:</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION complex_example() RETURNS text LANGUAGE plrust AS $$
    let result = fn_call("debug_format_args", &amp;[&amp;Arg::Value("hi"), &amp;Arg::&lt;i64&gt;::Null, &amp;Arg::&lt;f32&gt;::Default])?;
    Ok(result)    
$$;

SELECT complex_example();
complex_example        
------------------------------
 Some("hi"), None, Some(0.99)
(1 row)
</code></pre>
<p>You'll notice here that the <code>Arg::Null</code> and <code>Arg::Default</code> argument values are typed with <code>::&lt;i64&gt;</code> and <code>::&lt;f32&gt;</code>
respectively.  It is necessary for PL/Rust to know the types of each argument at compile time, so that during runtime
the proper function can be chosen.  This helps to ensure there's no ambiguity related to Postgres' function overloading
features.  For example, let's overload <code>debug_format_args</code> with a different type for the second argument:</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION debug_format_args(a text, b bool, c float4 DEFAULT 0.99) RETURNS text LANGUAGE plrust AS $$
    Ok(Some(format!("{:?}, {:?}, {:?}", a, b, c)))  
$$;

SELECT debug_format_args('hi', NULL);
ERROR:  42725: function debug_format_args(unknown, unknown) is not unique
LINE 1: SELECT debug_format_args('hi', NULL);
               ^
HINT:  Could not choose a best candidate function. You might need to add explicit type casts.
</code></pre>
<p>As you can see, even Postgres can't figure out which <code>debug_format_args</code> function to call as it doesn't know the intended
type of the second <code>NULL</code> argument.  We can tell it, of course:</p>
<pre><code class="language-sql">SELECT debug_format_args('hi', NULL::bool);
      debug_format_args       
------------------------------
 Some("hi"), None, Some(0.99)
(1 row)
</code></pre>
<p>Note that if we call our <code>complex_example</code> function again, now that we've added another version of <code>debug_format_args</code>,
it <em>still</em> calls the correct one -- the version with an <code>int</code> as the second argument.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>PL/Rust does <strong>not</strong> support dynamically calling functions with <code>OUT</code> or <code>IN OUT</code> arguments.  Nor does it support
calling functions that return <code>SETOF $type</code> or <code>TABLE(...)</code>.</p>
<p>It is possible these limitations will be lifted in a future version.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trusted-and-untrusted-plrust"><a class="header" href="#trusted-and-untrusted-plrust">Trusted and Untrusted PL/Rust</a></h1>
<p>Normally, PL/Rust is installed as a "trusted" programming language named <code>plrust</code>.
In this setup, certain Rust and <code>pgrx</code> operations are disabled to preserve security.
In general, the operations that are restricted are those that interact with the environment.
This includes file handle operations, require, and use (for external modules).
There is no way to access internals of the database server process or to gain
OS-level access with the permissions of the server process, as a C function can do.
Thus, any unprivileged database user can be permitted to use this language.</p>
<p>Here is an example of a function that will not work because file system operations are not allowed for security reasons:</p>
<pre><code>EXAMPLE COMING SOON
</code></pre>
<p>The creation of this function will fail as its use of a forbidden operation will be caught by the validator.</p>
<p>Sometimes it is desirable to write Rust functions that are not restricted.
To handle these cases, PL/Rust can also be installed as an "untrusted" language.
In this case the full Rust language is available including <code>unsafe</code> code.
See the
<a href="install-plrust.html#untrusted-install">Untrusted install section</a>
for steps to install untrusted PL/Rust.</p>
<p>The writer of an untrusted PL/Rust function must take care that the function cannot be used to do anything unwanted, since it will be able to do anything that could be done by a user logged in as the database administrator. Note that the database system allows only database superusers to create functions in untrusted languages.</p>
<p>If the above function was created by a superuser using the untrusted <code>plrust</code>, execution would succeed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="postgresql-configuration-for-plrust"><a class="header" href="#postgresql-configuration-for-plrust">PostgreSQL Configuration for PL/Rust</a></h1>
<p>PL/Rust has two <strong>required</strong> configuration options and a variety of non-required options.
These options are set in the standard <code>postgresql.conf</code> configuration file used
by PostgreSQL.</p>
<p>PL/Rust has two required configuration options in untrusted and trusted installations.
Using PL/Rust with cross compilation support has a 3rd required configuration option.
Failure to set these variables
will cause <code>plrust</code> extension to not function.</p>
<h2 id="required"><a class="header" href="#required">Required</a></h2>
<p>PL/Rust has two PostgreSQL configuration options that are always required for use,<code>shared_preload_libraries</code> and <code>plrust.work_dir</code>.</p>
<h4 id="shared_preload_libraries-string"><a class="header" href="#shared_preload_libraries-string"><code>shared_preload_libraries</code> (string)</a></h4>
<p>The <a href="https://www.postgresql.org/docs/current/runtime-config-client.html"><code>shared_preload_libraries</code> entry</a>
needs to include <code>plrust</code>. This is a comma separated list of libraries that
need to be pre-loaded in order to operate properly.</p>
<pre><code class="language-bash">shared_preload_libraries = 'plrust'
</code></pre>
<h4 id="plrustwork_dir-string"><a class="header" href="#plrustwork_dir-string"><code>plrust.work_dir</code> (string)</a></h4>
<p>The <code>plrust.work_dir</code> must be set to location for PL/Rust to save
necessary intermediate files. This path must be writable by the user running
the PostgreSQL process, typically <code>postgres</code> on common Linux distributions.</p>
<pre><code class="language-bash">plrust.work_dir = '/tmp'
</code></pre>
<h2 id="additional-configuration-options"><a class="header" href="#additional-configuration-options">Additional Configuration Options</a></h2>
<h4 id="plrustallowed_dependencies-string"><a class="header" href="#plrustallowed_dependencies-string"><code>plrust.allowed_dependencies</code> (string)</a></h4>
<p>Define the path to a <code>toml</code> file with an allow-list of Rust crates and versions when creating
PL/Rust functions.
When <code>plrust.allowed_dependencies</code> is not defined, all Rust crates are allowed
when creating PL/Rust functions.</p>
<p>For more discussion, see <a href="dependencies.html">dependencies.md</a></p>
<h4 id="plrustpath_override-string"><a class="header" href="#plrustpath_override-string"><code>plrust.path_override</code> (string)</a></h4>
<p>Set this if <code>cargo</code> and <code>cc</code> are not in the postmaster's <code>$PATH</code>.</p>
<pre><code class="language-bash">plrust.path_override = '/special/path/to/.cargo/bin:/usr/bin'
</code></pre>
<h4 id="plrusttrusted_pgrx_version-string"><a class="header" href="#plrusttrusted_pgrx_version-string"><code>plrust.trusted_pgrx_version</code> (string)</a></h4>
<p>The version of the <code>plrust-trusted-pgrx</code> crate from crates.io to use when
compiling user functions. By default, PL/Rust uses the same version of
<code>plrust-trusted-pgrx</code> as PL/Rust itself, and does not need to be explicitly set.</p>
<pre><code class="language-bash">plrust.trusted_pgrx_version = 'the.latest.version'
</code></pre>
<h4 id="plrusttracing_level-string"><a class="header" href="#plrusttracing_level-string"><code>plrust.tracing_level</code> (string)</a></h4>
<p>A <a href="https://docs.rs/tracing-subscriber/0.3.11/tracing_subscriber/filter/struct.EnvFilter.html">tracing directive</a>.</p>
<pre><code class="language-bash">plrust.tracing_level = 'info'
</code></pre>
<h2 id="required-for-cross-compilation"><a class="header" href="#required-for-cross-compilation">Required for Cross Compilation</a></h2>
<h4 id="plrustcompilation_targets-string"><a class="header" href="#plrustcompilation_targets-string"><code>plrust.compilation_targets</code> (string)</a></h4>
<p>Using PL/Rust with cross compilation requires the <code>plrust.compilation_targets</code>
configuration option.  This is required for PL/Rust to cross compile user functions.
The <code>plrust.compilation_targets</code> option is a comma-separated list of values,
of which only <code>x86_64</code> and <code>aarch64</code> are currently supported.</p>
<pre><code class="language-bash">plrust.compilation_targets = 'x86_64, aarch64'
</code></pre>
<p>For PL/Rust to cross compile user functions it needs to know which CPU architectures via
<code>plrust.compilation_targets</code>. This is a comma-separated list of values, of which only <code>x86_64</code> and <code>aarch64</code> are
currently supported.</p>
<h4 id="plrustarch_linker-string"><a class="header" href="#plrustarch_linker-string"><code>plrust.{arch}_linker</code> (string)</a></h4>
<p>This is the name of the linker <code>rustc</code> should use on for cross-compile.
The architecture linker names have sensible defaults and shouldn't need to be be
changed (unless the host is some esoteric Linux distribution we have not encountered yet).</p>
<p>Linux defaults:</p>
<pre><code class="language-bash">plrust.x86_64_linker = 'x86_64_linux_gnu_gcc'
plrust.aarch64_linker = 'aarch64_linux_gnu_gcc'
</code></pre>
<p>macOS defaults:</p>
<pre><code class="language-bash">plrust.x86_64_linker = 'cc'
plrust.aarch64_linker = 'cc'
</code></pre>
<h4 id="plrustarch_pgrx_bindings_path-string"><a class="header" href="#plrustarch_pgrx_bindings_path-string"><code>plrust.{arch}_pgrx_bindings_path</code> (string)</a></h4>
<p>The <code>plrust.{arch}_pgrx_bindings_path</code> settings are actually required but PL/Rust will happily cross compile without them. If unspecified,
PL/Rust will use the pgrx bindings of the host architecture for the cross compilation target architecture too. In other words, if the host
is <code>x86_64</code> and PL/Rust is configured to cross compile to <code>aarch64</code> and the <code>plrust.aarch64_pgrx_bindings_path</code> is <em>not</em> configured, it'll
blindly use the bindings it already has for <code>x86_64</code>.  This may or may not actually work.</p>
<p>To get the bindings, install <code>cargo-pgrx</code> on the other system and run <code>cargo pgrx cross pgrx-target</code>. That'll generate a tarball. Copy that back
to the primary host machine and <code>untar</code> it somewhere (PL/Rust doesn't care where), and use that path as the configuration setting.</p>
<p>Note that it is perfectly fine (and really, expected) to set all of these configuration settings on both architectures.
PL/Rust will silently ignore the one for the current host.  In other words, plrust only uses them when cross compiling for
the other architecture.</p>
<h2 id="lints"><a class="header" href="#lints">Lints</a></h2>
<p>There are two The PL/Rust configuration options related to lints. <strong>These options
should not be changed.</strong>
Altering these configuration options has two main negative side effects.
Disabling any of the pre-configured lints <strong>removes any and all expectation</strong>
of PL/Rust being trusted.
Changing this option can also prevent upgrading PL/Rust.</p>
<p>See the <a href="config-lints.html">Lints Configuration</a> section for more details about the
purpose of the Lints.</p>
<h4 id="plrustcompile_lints-string"><a class="header" href="#plrustcompile_lints-string"><code>plrust.compile_lints</code> (string)</a></h4>
<p>A comma-separated list of Rust lints to apply to every user function.</p>
<pre><code class="language-bash">plrust.compile_lints = 'plrust_extern_blocks, plrust_lifetime_parameterized_traits, implied_bounds_entailment, unsafe_code, plrust_filesystem_macros, plrust_env_macros, plrust_external_mod, plrust_fn_pointers, plrust_async, plrust_leaky, plrust_print_macros, plrust_stdio, unknown_lints, deprecated, suspicious_auto_trait_impls, soft_unstable, plrust_autotrait_impls'
</code></pre>
<h4 id="plrustrequired_lints-string"><a class="header" href="#plrustrequired_lints-string"><code>plrust.required_lints</code> (string)</a></h4>
<p>A comma-separated list of Rust lints that are required to have been applied to a user function before PL/Rust will load the library and execute the function.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>PL/Rust, a Rust-based extension built using <a href="https://github.com/tcdi/pgrx">pgrx</a>, provides a procedural language handler for Rust in PostgreSQL. When installed, PL/Rust allows this to work:</p>
<pre><code class="language-sql">CREATE FUNCTION {fn_name} ({args})
RETURNS {ret}
-- function attributes can go here
AS $$
    // PL/Rust function body goes here
    // All PL/Rust functions return Result&lt;Option&lt;{ret}&gt;&gt;
$$ LANGUAGE plrust;
</code></pre>
<p>PL/Rust will compile the function as a dynamic library, load it, and execute it.</p>
<h2 id="trusted-language"><a class="header" href="#trusted-language">Trusted Language</a></h2>
<p>In order to create a <a href="https://www.postgresql.org/docs/current/sql-createlanguage.html">trusted</a> language handler in PostgreSQL we must restrict the functions compiled and executed by the language handler to the set of operations other code in PostgreSQL has access to.</p>
<ul>
<li>No operations on files except through the database itself</li>
<li>Limit access to the database to that of other procedural language functions</li>
<li>Limit access to system resources to those of a trusted language user function</li>
<li>It must be sound enough to allow any unprivileged database user to use the language (<a href="https://www.postgresql.org/docs/current/plperl-trusted.html">postgresql.org</a>)</li>
</ul>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<p>A target tuple describes a "platform" that can execute code. Rust uses rustc, which requires that code is ahead-of-time compiled in order to do code generation, so it requires a target tuple that defines the code object it must generate. A code object has a format (e.g. ELF or Windows PE) which an operating system supports, instructions (e.g. aarch64 or wasm) which a machine architecture supports, and calls to system interfaces to the operating system (such as via GNU <code>libc.so</code> or MacOS <code>libSystem.dylib</code>) which require holistic support. These code objects may be executables (which the system may initialize as a process) or libraries (which may be "linked", relocating code from them into the final executable at build time, or loading their code to call at runtime). Libraries used at build time are also called static libraries, objects, or archives. Libraries used at runtime are also called dynamic libraries or shared objects.</p>
<p>The Rust compiler builds the Rust standard library as a static library and then links it into Rust code objects. The contents of this static library include the code which dynamically links against system interfaces. These system interfaces are what postgrestd intercepts by itself being a modification of the Rust standard library.</p>
<p>The extension called "PL/Rust" which includes the language handler is responsible for covering the linking and loading steps. This extension may have privileges that user functions do not, using the Rust std of the same host target that PostgreSQL itself is compiled for, to interoperate in that privileged mode. This is as-usual for language handlers: they must typically be written in C.</p>
<h2 id="design-goals"><a class="header" href="#design-goals">Design Goals</a></h2>
<p>Design a custom rust compilation target for PostgreSQL that provides nearly "safe" (as Rust defines it) and "trusted" (as PostgreSQL defines a procedural language) PL/Rust.</p>
<p>The goals for the approach include</p>
<ul>
<li>Architecture support for x86_64 and aarch64</li>
<li>Operating system support for Linux</li>
<li>Disallow File Handle operations</li>
<li>Disallow access to the internals of the database</li>
<li>Disallow access to the OS as the user executing the PostgreSQL process</li>
<li>Disallow access into active postmaster process, i.e. no ability to reach into PostgreSQL memory space, despite executing inside it.</li>
<li>Gracefully handle rust panics and have them interoperate with PostgreSQL's transaction system</li>
<li>Memory allocation within PostgreSQL's palloc/pfree functions</li>
</ul>
<h2 id="approach"><a class="header" href="#approach">Approach</a></h2>
<p>Following an approach similar to the selection between libc and the musl libc standard library for compilation, a PostgreSQL compilation target is defined that instructs the compiler to use the postgrestd library.  The postgrestd library provides the rust standard library interfaces except in the case where it is desirable to prevent access.  In those cases the code is <a href="https://doc.rust-lang.org/stable/rust-by-example/attribute/cfg.html">configured</a> to be not present. The result is a small shim on top of the rust library limited access to the standard library.</p>
<h2 id="birds-eye-view"><a class="header" href="#birds-eye-view">Bird's Eye View</a></h2>
<p><img src="assets/architecture_1.png" alt="" /></p>
<h2 id="supporting-crates"><a class="header" href="#supporting-crates">Supporting Crates</a></h2>
<p>Because PL/Rust implements a fairly complicated language with the intention to make it sound to use as a trusted procedural language, there are multiple supporting crates necessary to make it work.</p>
<h3 id="postgrestd"><a class="header" href="#postgrestd">postgrestd</a></h3>
<p>See <a href="https://github.com/tcdi/postgrestd">postgrestd</a> for more details.</p>
<h2 id="cross-cutting-concerns"><a class="header" href="#cross-cutting-concerns">Cross-Cutting Concerns</a></h2>
<p>This sections talks about the things which are everywhere and nowhere in particular.</p>
<h3 id="code-generation"><a class="header" href="#code-generation">Code generation</a></h3>
<p>PL/Rust uses <a href="https://doc.rust-lang.org/cargo/guide">Cargo</a> for code generation. Each function is built as its own crate to allow it to be individually dynamically loaded (however this is not a strict requirement: multiple functions could be generated together, it's merely a current implementation detail that simplifies some handling).</p>
<p>PL/Rust builds reuse the same build directory to assist in exploiting the existing <a href="https://doc.rust-lang.org/cargo/guide/build-cache.html">build caching</a> implemented in Cargo. However, because of the <a href="https://doc.rust-lang.org/cargo/reference/resolver.html">resolver</a>, as soon as dependencies are involved, and because building PL/Rust code involves a nonzero number of default crate dependencies, the exact build graph may vary from build to build even for what appears to be the "same crate" to a programmer, as subtle changes in feature or version resolution can all cause the crate to need to be recompiled.</p>
<h3 id="cancellation"><a class="header" href="#cancellation">Cancellation</a></h3>
<h3 id="testing"><a class="header" href="#testing">Testing</a></h3>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<h3 id="observability"><a class="header" href="#observability">Observability</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="designing-for-trust"><a class="header" href="#designing-for-trust">Designing for Trust</a></h1>
<h1 id="a-note-on-definitions"><a class="header" href="#a-note-on-definitions">A note on definitions</a></h1>
<p>In order to allow building a Postgres extension in Rust, quite a lot of bindings to C code are required,
and a language handler is necessarily a Postgres "C" function, which is usually packaged as a Postgres extension.
Since the only Postgres extension of true concern for PL/Rust is the language handler and associated components,
and most other functions that will be embedded in Postgres will be managed by this extension, I will redefine the difference arbitrarily for this document: the language handler is a Postgres extension, and "Postgres function" will be used to refer to any Postgres function <em>except</em> a language handler.</p>
<h1 id="the-goal"><a class="header" href="#the-goal">The goal</a></h1>
<p>Nominally, to make PL/Rust exist: a dialect of Rust nested in SQL that can function as a "trusted procedural language".</p>
<h1 id="the-caveat"><a class="header" href="#the-caveat">The caveat</a></h1>
<p>A major obstacle to making PL/Rust a trustworthy language is that Rust is not an intrinsically safe language.</p>
<p>Again, Rust is not an intrinsically safe language.</p>
<p>There are three major details to this:</p>
<ol>
<li>Rust has not been formally verified to have all of the safety properties it intends to have. Bugs exist that undoubtedly violate its own design for memory safety. These bugs will eventually be fixed, because there is no soundness bug that is considered a "breaking change", or rather, Rust considers all flaws in its type system that would prevent the type system from verifying memory safety to be acceptable to change and they are explicitly not governed by any stability promises. Nonetheless, Rust is only as safe as its implementation is safe.</li>
<li>Rust is split into two sublanguages: Safe Rust and Unsafe Rust. Most Rust is Safe Rust. An <code>unsafe { }</code> block allows the usage of Unsafe Rust code, and most Unsafe Rust code item declarations are also annotated with <code>unsafe</code><sup class="footnote-reference"><a href="#1">1</a></sup>. It is required to have Unsafe Rust as an implementation primitive in order to be able to specify the behavior of Rust: otherwise it would have to be written in another, also memory-unsafe language. By using both as part of Rust, certain guarantees based in the type system can traverse between Safe and Unsafe Rust and remain intact. Otherwise, the work to prove the type soundness would have to begin entirely within Safe Rust, without the ability to incrementally validate claims. However, this means that Unsafe Rust is always waiting behind all Safe Rust, so the abstraction boundary must be evaluated carefully.</li>
<li>Rust is not safe against all logic errors, nor does it consider all operations to be <code>unsafe</code> that the programmer might think of as <code>unsafe</code>. For instance, Rust considers <code>panic!</code> to be "safe": arguably, it is very not safe for <em>someone</em> if Rust code forms the core of an actively-running flight system for some airplane or helicopter and an uncaught panic terminates the flight system abruptly, rendering it inoperative for sufficiently long that the flight system cannot recover stability even after it reboots. It is also usually considered safe to perform IO on arbitrary files, but a database might take a dim view of writing to its storage files.</li>
</ol>
<p>This three-part caveat, one might notice, is largely a problem of <em>definition</em>:</p>
<ol>
<li>Safe according to whom?</li>
<li>Safe for what uses?</li>
<li>Safe in which context?</li>
</ol>
<p>However, each of these remain distinct issues because they cover different domains: validity, implementation, and context.</p>
<h2 id="is-trust-insufficient-paranoia"><a class="header" href="#is-trust-insufficient-paranoia">Is Trust Insufficient Paranoia?</a></h2>
<p>The caveats that apply to Rust apply in very similar form to other existing procedural languages, whether or not they are "trusted":</p>
<ol>
<li>The question is not whether there is another vulnerability to discover in PL/Tcl, PL/Perl, PL/pgSQL, or with their shared interface with PostgreSQL: it's how long it will take to find it, whether anyone bothers to look, and whether it can actually be used to inflict damage.</li>
<li>The trusted procedural languages have an underlying implementation in a memory-unsafe language. This poses the question of whether those languages are fully secure against the surface implementation being used to achieve unsafe effects. They undoubtedly are against trivial attacks.</li>
<li>Some undesirable effects can still be achieved via the procedural languages. Notably, it's not clear they have much of a defense against e.g. using infinite loops to lock up that thread of execution rather than proceed further.</li>
</ol>
<p>This is not to say these languages are equally safe or unsafe: there's some advantages in being able to deploy dynamic checks.
It merely is to observe that in the presence of sufficient paranoia, all implementations for all languages that exist are hard to trust.
Web browsers face similar dilemmas, and many users run browsers with JavaScript limited or disabled because they do not trust it, despite its sandboxing.
Any trusted language still means allowing arbitrary users with access to the database to execute code within that database which has broad capabilities.
If there is a weak point those capabilities can be applied to break through, and an attacker cares enough to keep searching, it will be found.</p>
<p>In effect, "trust" in practice only exists in two cases:</p>
<ul>
<li>not being aware of the consequences</li>
<li>being willing to accept the possibility that worst-case consequences might happen</li>
</ul>
<h1 id="safety-and-trust-are-implementation-defined"><a class="header" href="#safety-and-trust-are-implementation-defined">Safety and trust are implementation-defined</a></h1>
<p>Rust defines "safety" around the concept of "memory safety", and uses a type system that includes ownership types to implement that.</p>
<p>For PostgreSQL's database code, a "trusted procedural language" has only one concrete definition:
Did a database administrator install it with the TRUSTED designation?
There's nothing technically stopping a DBA with the appropriate privileges from installing an "untrusted" language as TRUSTED in PostgreSQL.</p>
<p>A more amorphous but more practically useful definition is extensively implied throughout the documentation on procedural language:
A trusted procedural language is a language where, if you install it as TRUSTED, this decision will not immediately bite you on the ass.
The Postgres documentation defines this kind of "trusted" around the idea of limiting trusted language code to effects that either
are of no consequence to the database or that the database was going to allow a user to hypothetically do anyway,
and it uses dynamic checks and SQL roles to assist implementing that.
Specifically, this means a trusted language's code should also respect SQL roles and not produce unintentional denials of service.
It may still serve as an attack vector on the system, as can normal SQL-DDL commands, but if it does,
it should make it slightly more frustrating for an attacker than running arbitrary assembly (AKA shellcode) would permit.
Many attacks of this nature unfortunately will still end in being able to run shellcode if successful.</p>
<p>It may be worth drawing a parallel to cryptography, another way of assuring data security and integrity:
many supposedly "one-way" hash functions can theoretically be reversed by an attacker with sufficient power.
The security of hashed data usually instead lies in making it so that the attacker would require large amounts of computational power,
considerable time, and probably at least one or two novel breakthroughs in the understanding of computation itself,
or else they may be spending so much time that the Earth will grow cold before they can unlock the data.
Or hopefully at least a few days, allowing time for, say, discovering the breach and generating new passwords.
We call something that achieves this goal "secure", even though in actuality it is in fact "eventually breakable".
Likewise, a "trusted procedural language" will in practice be "eventually breakable",
and the goal is not necessarily to be inviolate but to offer some resistance.</p>
<p>A quality implementation of a trusted procedural language should offer enough resistance that you can worry much less.
The rest of this discussion will revolve around what is ultimately a proposal to implement PL/Rust
as a high-quality trusted procedural language and how to evaluate that as an ongoing event,
rather than one that is necessarily expected to be "finished".</p>
<h1 id="solving-the-problems"><a class="header" href="#solving-the-problems">Solving the problems</a></h1>
<p>A perfectly elegant solution would address all of these parts of the problem in one swoop.
However, that would require there to be some unifying dilemma that, if answered, can easily handle all of these outward projections.
Unfortunately, a formally-verified wasm virtual machine that can be used to safely execute arbitrary Rust code inside it,
yet still bind easily against PostgreSQL's C API is... a tall order. In other words, the more elegant solution simply doesn't exist yet.</p>
<p>Because such a provably-secure-yet-porous-enough wasm sandbox currently doesn't exist, it's debatable if it would actually elegantly solve the issue, as we can't actually assess that claim.
Notably, it's not clear that allowing arbitrary bindings in such a wasm sandbox would not simply create a sandbox that can do dangerous things.
A protective box that encloses its contents yet still has many dangerous projections outside it is usually called a "tank",
and is considered to be a weapon of war, which may not be something you wish to introduce into your database.</p>
<p>So in this, more clumsy world, such a three-part problem calls for a three-part solution... at least.</p>
<ol>
<li>To align Safe Rust more closely with what Postgres expects a trusted language to be able to do, replace <code>std</code> with <code>postgrestd</code>.</li>
<li>To prevent Unsafe Rust from being used to violate expectations, bar the use of <code>unsafe</code> code.</li>
<li>Deploy any and all additional hardening necessary.</li>
<li>Keep doing that, actually: Defense in depth is a good thing.</li>
</ol>
<p>Eventually, using more effective and total layers of sandboxing can be used when that becomes more convenient, but the problem would remain:
Normally, Rust code has the ability to call bindings that can do things a trusted procedural language should not be allowed to do,
so if you allow Rust to bind calls to arbitrary external functions into wasm, then you allow Rust to "break trust".
A comprehensive approach that blocks off these exit routes is still required, and any additional sandboxing serves as reinforcement.</p>
<h2 id="safety-unwinding-and-impl-drop"><a class="header" href="#safety-unwinding-and-impl-drop">Safety, Unwinding, and <code>impl Drop</code></a></h2>
<details>
<summary>
Needs rewrite after rewrite of PGRX error handling
</summary>
<p>In Rust, the <code>Drop</code> trait promises that if execution reaches certain points in a program then a destructor has been run.
There is an immediate and obvious problem with this: Rust does not guarantee forward progress and includes diverging control flow that "never returns".
Thus it is possible for Rust code to never reach certain points in control flow, such as by invoking <code>panic!()</code> first.
Normally, however, <code>panic!()</code> will cause "unwinding", which walks back through Rust code to the nearest <code>catch_unwind</code>, running <code>Drop</code> as it goes.</p>
<p>However, this is not always the case, and <code>panic!()</code> may be implemented by other forms of divergence such as immediate termination.
This may seem surprising, but it is a simple extension of the natural observation that <code>SIGKILL</code> exists,
or its sundry equivalents on non-Unix-like operating systems, and Rust code usually runs under an operating system.
Rust does not consider terminating Rust code to be a violation of memory safety, because ceasing to progress
is considered the appropriate way to respond to a situation where the program is not capable of soundly handling further events.
A possible event that can cause this is the "panic-in-panic" scenario: if unwinding also causes a panic, Rust simply aborts.</p>
<p>In a more targeted fashion, it is possible also to <code>mem::forget</code> something with <code>Drop</code>, or to wrap it in <code>ManuallyDrop</code>.
Together, these facts mean that a destructor can never be relied on to be run when following arbitrary control flow.
Only Rust control flow that lacks these features can be expected to run all destructors.
In other words: <code>Drop</code> can be intercepted by both events inside normal Rust code and also "outside" it.</p>
</details>
<!--
need to discuss:
- statics
- unwind runtimes
- landing pads and where they are located in PL/Rust contexts
- maybe thread safety?
- other stuff with palloc?
-->
<h2 id="controlling-unsafe"><a class="header" href="#controlling-unsafe">Controlling <code>unsafe</code></a></h2>
<p>Code can by hypothetically verified to be "safe" by either scanning the tokens directly using a procedural macro or by compiling it with various lints of the Rust compiler to detect and constrain use of <code>unsafe</code> enabled.</p>
<h3 id="is-automatically-blocking-all-unsafe-code-enough"><a class="header" href="#is-automatically-blocking-all-unsafe-code-enough">Is automatically blocking all <code>unsafe</code> code enough?</a></h3>
<p>No.</p>
<p>The problem with blocking all <code>unsafe</code> code is that pgrx, the Rust standard library, and essentially all implementation details of PL/Rust,
will be implemented using <code>unsafe</code> code. There are also many crates which are soundly implemented and theoretically fine to use for PL/Rust,
but rely on an <code>unsafe</code> implementation primitive.</p>
<p>Further, some way must exist to implement the function call interface from PostgreSQL to Rust code.
In PL/Rust, that is done via the <a href="https://crates.io/crates/pgrx/">pgrx crate</a>. This requires a lot of <code>unsafe</code> code.
Thus, in order to compile any PL/Rust function, <em>a lot of unsafe code must be used</em>.
This also means that something must be done to prevent the use of pgrx's <code>unsafe fn</code> in PL/Rust
while still allowing pgrx to use <code>unsafe</code> code to implement its own interfaces.</p>
<h3 id="plutonium"><a class="header" href="#plutonium">plutonium</a></h3>
<h2 id="postgrestd-containing-the-problem"><a class="header" href="#postgrestd-containing-the-problem"><code>postgrestd</code>: containing the problem</a></h2>
<p>If Rust is not allowed to bind against arbitrary external interfaces, then it only has <code>std</code> and whatever crates are permitted.
This makes controlling <code>std</code> a priority, and <code>postgrestd</code> is used to implement that.</p>
<p>The result of this is that as long as only Rust code compiled with the <code>postgrestd</code> fork is executed via PL/Rust,
and as long as e.g. arbitrary <code>unsafe asm!</code> is not permitted, an escalation in privileges
cannot simply jump outside the database and start doing arbitrary things.
It is limited to subverting the database, which admittedly is still a bountiful target,
but in this event containing the database itself can still be meaningfully done.</p>
<h2 id="the-other-elephant-in-the-room-pgrx"><a class="header" href="#the-other-elephant-in-the-room-pgrx">The other elephant in the room: pgrx</a></h2>
<p>In addition to being used as the implementation detail of PL/Rust, pgrx offers a full-fledged interface for building Postgres extensions in general.
This means that like the Rust standard library, pgrx is not perfectly adapted to being an interface for a trusted procedural language.
There are two possible options in carving out what parts of pgrx are appropriate to use:</p>
<ul>
<li>remove all inappropriate features behind <code>#[cfg]</code> blocks, OR</li>
<li>create a separate crate and expose it as the pgrx-Postgres user-callable interface</li>
</ul>
<p>Neither of these are perfectly satisfying because neither option provides a neatly-defined, automatic answer
to the question "of pgrx's safe code, what should be allowed?" to begin with.</p>
<p>There is also the unfortunate question of "is pgrx's safe code actually sound?"
The crate's early implementation days included a few declared-safe wrappers that didn't fully check all invariants,
and in some cases did not document the implied invariants, so an <a href="https://github.com/tcdi/pgrx/issues/843">audit of code in pgrx</a> is required.
There is no getting around this, as it falls back on the fundamental problem of all procedural languages:
They can only be as trustworthy as their implementations, which puts a burden on their implementation details to be correct.
Fortunately, most of this audit has already been accomplished simply by the crate receiving scrutiny over the past 3 years.</p>
<h2 id="building-arbitrary-crates"><a class="header" href="#building-arbitrary-crates">Building arbitrary crates</a></h2>
<p>Part of what makes Rust such a useful language is that it has crates.io: an ecosystem that allows easy sharing of code,
like most "dynamic" languages do, with very little support needed from an operating system's package manager,
yet is a systems programming language. Thus, it's inevitable that PL/Rust will want to be able to build arbitrary dependencies.
In fact, it has to add at least a few specially approved crates, its own build dependencies like pgrx, in order to build Rust code,
but we have to fully trust those crates anyways, so this is nothing new.
But using crates we may not necessarily want to automatically trust introduces many, many complications as a direct result.</p>
<p>Some of the primary concerns:</p>
<ul>
<li>build.rs</li>
<li>procedural macros</li>
<li><code>unsafe</code> code in dependencies</li>
<li><code>#[cfg]</code> for a very strange runtime</li>
</ul>
<h1 id="future-directions"><a class="header" href="#future-directions">Future directions</a></h1>
<p>When you allow a user to run code in your database's process, you are allowing them to attempt to subvert that process,
so all users to some extent must <em>also</em> be trusted with the tools you are giving them,
claims that trusted procedural languages allow untrusted users to run untrusted code besides. They just can be trusted <em>less</em>.
However, if a user is expected to possibly "sublet" their tenancy to another user, creating a complex multitenancy situation,
where the current superuser adopts the position of a "hyperuser", and the user adopts the position of "virtual superuser",
the hyperuser who decides what languages are installed may still want to allow the virtual superuser's guests to run code,
but has to be aware that they have <em>even less</em> trust.
This means various traditional attack venues, e.g. heap attacks, become even more of a concern,
as the hyperuser may have to mount a defense against the virtual superuser's guests,
and the virtual superuser may install and run PL/Rust code on behalf of these guests.</p>
<p>These are possible future directions in adding layers of security, not currently implemented or experimented with yet.</p>
<h2 id="dynamic-allocator-hardening"><a class="header" href="#dynamic-allocator-hardening">Dynamic allocator hardening?</a></h2>
<p>While PL/Rust merely interposes palloc, it... still interposes palloc. This means it can implement a "buddy allocator".
Since it's possible to control the global allocator for Rust code, this can help interfere with attacks on the heap.
This is likely necessary, at the cost of some runtime overhead (offset by PL/Rust precompiling code for execution speed),
to buy security against any attacks that target flaws in the Rust type system when those issues are not solved.
Having to do this to harden a "memory-safe" language is not unusual, and the system administrator
should be aware of this when deploying PostgreSQL and consider deploying PostgreSQL with a similarly hardened allocator
so that all allocations benefit from this protection, but it's not unreasonable to want a second layer for PL/Rust.</p>
<h2 id="background-worker-executor"><a class="header" href="#background-worker-executor">Background worker executor?</a></h2>
<p>The process boundary offers a great deal of resilience against heap attacks. Background workers are separate processes, and
PL/Java implementations use a similar approach of running code inside a daemon (which also takes care of compiling code).
This may trade off a lot of performance gains from PL/Rust's overall approach, but it still may be worth it.</p>
<h2 id="control-flow-integrity"><a class="header" href="#control-flow-integrity">Control Flow Integrity</a></h2>
<p>There are various hardware-, kernel-, or compiler-level approaches to protect the integrity
of even C or C++ code against reasonably determined attackers trying to usurp its control flow.
Thus these approaches are sometimes called "control flow integrity" collectively,
but they have various specific brand names like "indirect branch targeting", "control flow guard",
or "pointer authentication". The Rust compiler supports a number of these as nightly features,
and while they require Postgres to also be built with support these features for them to work,
it would be worth exploring their use for PL/Rust.</p>
<h2 id="witx-the-wasm-strikes-back"><a class="header" href="#witx-the-wasm-strikes-back">witx: the wasm strikes back</a></h2>
<p>A method of generating bindings for wasm automatically is being prototyped,
called witx, which builds on "WebAssembly Interface Types".
It's not currently ready for primetime, but it is possible that
within a few years it may be a feasible answer to many of these problems,
especially in terms of hardening the Rust stack and heap against code
just doing arbitrary nonsense to it, even if things get overly "interesting".</p>
<h1 id="notes"><a class="header" href="#notes">Notes</a></h1>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>There are a few cases where Unsafe Rust code can be declared without it being visibly denoted as such, and these are intended to be phased out eventually, but in these cases they generally still require an <code>unsafe { }</code> block to be called or they must be wrapped in an <code>unsafe fn</code>. The absence of the <code>unsafe</code> token can only be bypassed in Rust by declaring an <code>extern fn</code> (which is implicitly also an <code>unsafe fn</code>, allowing one to fill it with other <code>unsafe</code> code) and then calling that function from another language, like C.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-dependencies"><a class="header" href="#external-dependencies">External Dependencies</a></h1>
<p>PL/Rust supports the use of external dependencies. By default, this is unrestricted even when PL/Rust is used as a
Trusted Language Handler, allowing user functions to specify any desired dependency.</p>
<p>For instance:</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION randint() RETURNS bigint LANGUAGE plrust AS $$
[dependencies]
rand = "0.8"

[code]
use rand::Rng; 
Ok(Some(rand::thread_rng().gen())) 
$$;
</code></pre>
<p>It is recommended that administrators create a dependency allow-list file and specify its path in <code>postgresql.conf</code> using
the <code>plrust.allowed_dependencies</code> setting.</p>
<p>To disable external dependencies completely, create a zero-byte file or point the configuration to <code>/dev/null</code>.</p>
<h2 id="the-allow-list-file"><a class="header" href="#the-allow-list-file">The Allow-List File</a></h2>
<p>The dependency allow-list is a TOML file. Its format mirrors that of the <code>[dependencies]</code> section in a standard
<code>Cargo.toml</code>, albeit with certain requirements on the version strings.</p>
<h3 id="the-format"><a class="header" href="#the-format">The Format</a></h3>
<p>The file consists of <code>dependency_name = version_requirement</code> pairs, where <code>version_requirement</code> can adopt several forms.
It can be a quoted string such as <code>"=1.2.3"</code>, a TOML table like <code>{ version = "=1.2.3", features = ["a", "b", "c"] }</code>, or
an array of either, such as <code>[ "=1.2.3", { version = "=1.2.3" }, "&gt;=4, &lt;5"</code>.</p>
<p>Here is a valid allow-list file for reference:</p>
<pre><code class="language-toml">rand = "&gt;=0.8, &lt;0.9"
bitvec = ["&gt;=1, &lt;2", "=0.2", { version = "=1.0.1", features = [ "alloc" ], default-features = false }]
</code></pre>
<p>This added flexibility empowers administrators to specify the exact crate version and its associated features and properties.</p>
<p>When a <code>LANGUAGE plrust</code> function designates a dependency and version, the largest (presumably most recent) matching
version from the allow-list is used.</p>
<h3 id="version-requirement-format"><a class="header" href="#version-requirement-format">Version Requirement Format</a></h3>
<p>PL/Rust employs Cargo's interpretation of semver to manage dependency versions, but it requires each version requirement
to be an exact value like <code>=1.2.3</code>, a bounded range such as <code>&gt;=1, &lt;2</code>, or a bare wildcard (<code>*</code>).</p>
<p>For example, these are valid version requirement values:</p>
<pre><code class="language-toml">rand = "=0.8.5"
serde = "&gt;=1.0.151, &lt;1.1"
bitvec = "*"
</code></pre>
<p>These, however, are not:</p>
<pre><code class="language-toml">rand = "0.8.5"
serde = "&gt;1.1"
</code></pre>
<p>The <code>cargo</code> tool may select a slightly different version based on the specification. However, with exact and bounded
values, <code>cargo</code>'s choices are limited to the versions that administrators allow.</p>
<p>The bare wildcard pattern (<code>*</code>) is acceptable and has a unique interpretation within a user <code>LANGUAGE plrust</code> function.</p>
<h3 id="using-a-dependency"><a class="header" href="#using-a-dependency">Using a Dependency</a></h3>
<p>As shown above, a <code>LANGUAGE plrust</code> function can include a <code>[dependencies]</code> section. Authors should specify exact versions
for each dependency. PL/Rust will match this exact version with an entry in the allow-list.</p>
<p>If a function requests a version in the <code>1.2.3</code> format and it matches an entry on the allow-list, PL/Rust will revise
it to an exact version, i.e., <code>=1.2.3</code>.</p>
<p>If the allow-list merely contains a wildcard version:</p>
<pre><code class="language-toml">rand = "*"
</code></pre>
<p>... and the user function asks for a specific version, such as <code>0.8.5</code>, PL/Rust will utilize that exact version.</p>
<p>Conversely, if the allow-list specifies one or more particular version requirements...</p>
<pre><code class="language-toml">rand = [ "0.8.5", "0.6" ]
</code></pre>
<p>... and the PL/Rust function requests a wildcard (i.e., <code>rand = "*"</code>), PL/Rust will select the largest version requirement
from the allow-list. In this case, it would be <code>0.8.5</code>.</p>
<h3 id="working-with-crate-features"><a class="header" href="#working-with-crate-features">Working with Crate Features</a></h3>
<p>When a user function employs a crate from the allow-list, the allow-list controls the permitted set of dependency properties
such as <code>features</code> and <code>default-features</code> for each version. Users cannot override these. They can specify them, but the
specifications must match exactly with the allow-list.</p>
<p>This control enables administrators to dictate the usage of dependencies.</p>
<p>For instance, this would be acceptable for a user function:</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION randint(seed bigint) RETURNS bigint STRICT LANGUAGE plrust AS $$
[dependencies]
rand = { version = "*", features = [ "small_rng" ], default-features = false }

[code]
use rand::rngs::SmallRng;
use rand::SeedableRng;
use rand::RngCore;

let mut rng = SmallRng::seed_from_u64(seed as _);
Ok(Some(rng.next_u64() as _))
$$;
</code></pre>
<p>Provided that the allow-list includes the following:</p>
<pre><code class="language-toml">rand = { version = "=0.8.5", features = [ "small_rng" ], default-features = false }
</code></pre>
<p>Note that the user function could omit the dependency features since the allow-list declares them:</p>
<pre><code class="language-sql">CREATE OR REPLACE FUNCTION randint(seed bigint) RETURNS bigint STRICT LANGUAGE plrust AS $$
[dependencies]
rand = "*"

[code]
use rand::rngs::SmallRng;
use rand::SeedableRng;
use rand::RngCore;

let mut rng = SmallRng::seed_from_u64(seed as _);
Ok(Some(rng.next_u64() as _))
$$;
</code></pre>
<p>PL/Rust provides a function <code>plrust.allowed_dependencies</code> which lists all the allowlisted crates with their respective enabled features. For example, with an allowlist as follows:</p>
<pre><code class="language-toml">rand = "&gt;=0.8, &lt;0.9"
bitvec = ["&gt;=1, &lt;2", "=0.2", { version = "=1.0.1", features = [ "alloc" ], default-features = false }]
</code></pre>
<p>The result of <code>plrust.allowed_dependencies</code> would be:</p>
<pre><code class="language-sql">SELECT * FROM plrust.allowed_dependencies();
  name  |   version   | features | default_features
--------+-------------+----------+------------------
 bitvec | =0.2        | {}       | t
 bitvec | &gt;=1, &lt;2     | {}       | t
 bitvec | =1.0.1      | {alloc}  | f
 rand   | &gt;=0.8, &lt;0.9 | {}       | t
(4 rows)
</code></pre>
<h3 id="operational-notes"><a class="header" href="#operational-notes">Operational Notes</a></h3>
<ul>
<li>The dependency allow-list file path must be set in <code>plrust.allowed_dependencies</code> GUC value in <code>postgresql.conf</code>.</li>
<li>Changing the GUC value requires a configuration reload on the database to take effect.</li>
<li>The file must be readable by the user that runs Postgres backend connections. Typically, this user is named <code>postgres</code>.</li>
<li>Every time a <code>CREATE FUNCTION ... LANGUAGE plrust</code> statement is executed, the file is read, parsed, and validated. This arrangement allows administrators to edit it without needing to restart the Postgres cluster.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lints-1"><a class="header" href="#lints-1">Lints</a></h1>
<p>PL/Rust has its own "rustc driver" named <code>plrustc</code>.  This must be installed using the
<a href="plrustc/build.sh"><code>plrustc/build.sh</code></a> script and the resulting executable must be on the <code>PATH</code>, or it should reside
somewhere that is included in the <code>plrust.PATH_override</code> GUC.</p>
<p>PL/Rust uses its own "rustc driver" so that it can employ custom lints to detect certain Rust code idioms and patterns
that trigger "I-Unsound" bugs in Rust itself.  Think "clippy" but built into the Rust compiler itself. In addition to
these custom lints, PL/Rust uses some standard Rust lints to enforce safety.</p>
<p>The <code>plrust.required_lints</code> GUC defines which lints must have been applied to a function before PL/Rust will load the
library and execute the function.  The default value is the empty set -- PL/Rust will not require any specific lints to
have been previously applied to a function.</p>
<p>Using the <code>PLRUST_REQUIRED_LINTS</code> environment variable, it is possible to enforce that certain lints are always required
of compiled functions, regardless of the <code>plrust.required_lints</code> GUC value.<code>PLRUST_REQUIRED_LINTS</code>'s format is a
comma-separated list of lint named.  It must be set in the environment in which Postgres is started.  The intention here
is that the system administrator can force certain lints for execution if for some reason <code>postgresql.conf</code> or the users
able to modify it are not trusted.</p>
<p>In all cases, these lints are added to the generated code which wraps the user's <code>LANGUAGE plrust</code> function, as
<code>#![forbid(${lint_name})]</code>.  They are used with "forbid" to ensure a user function cannot change it back to "allow".</p>
<p>PL/Rust does <strong>not</strong> apply these lints to dependant, external crates.  Dependencies <em>are</em> allowed to internally use
whatever code they want, including <code>unsafe</code>.  Note that any public-facing <code>unsafe</code> functions won't be callable by a plrust
function.</p>
<p>Dependencies are granted more freedom as the usable set can be controlled via the <code>plrust.allowed_dependencies</code> GUC.</p>
<hr />
<p><strong>It is the administrator's responsibility to properly vet external dependencies for safety issues that may impact
the running environment.</strong></p>
<hr />
<p>Any <code>LANGUAGE plrust</code> code that triggers any of the below lints will fail to compile, indicating the triggered lint.</p>
<h2 id="standard-rust-lints"><a class="header" href="#standard-rust-lints">Standard Rust Lints</a></h2>
<h3 id="unknown_lints"><a class="header" href="#unknown_lints"><code>unknown_lints</code></a></h3>
<p>https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html#unknown-lints</p>
<p>PL/Rust won't allow any unknown (to our "rustc driver") lints to be applied.  The justification for this is to mainly
guard against type-os in the <code>plrust.compile_lints</code> GUC.</p>
<h3 id="unsafe_code"><a class="header" href="#unsafe_code"><code>unsafe_code</code></a></h3>
<p>https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#unsafe-code</p>
<p>PL/Rust does not allow usage of <code>unsafe</code> code in <code>LANGUAGE plrust</code> functions.  This includes all the unsafe idioms such
as dereferencing pointers and calling other <code>unsafe</code> functions.</p>
<h3 id="implied_bounds_entailment"><a class="header" href="#implied_bounds_entailment"><code>implied_bounds_entailment</code></a></h3>
<p>https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html#implied-bounds-entailment</p>
<p>This lint detects cases where the arguments of an impl method have stronger implied bounds than those from the trait
method it's implementing.</p>
<p>If used incorrectly, this can be used to implement unsound APIs.</p>
<h3 id="deprecated"><a class="header" href="#deprecated"><code>deprecated</code></a></h3>
<p>https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html#deprecated</p>
<p>The deprecated lint detects use of deprecated items. This is forbidden because certain items in the Rust standard library are incorrectly-safe APIs but were only deprecated rather than removed when a version with the appropriate safety annotation was added.</p>
<h3 id="suspicious_auto_trait_impls"><a class="header" href="#suspicious_auto_trait_impls"><code>suspicious_auto_trait_impls</code></a></h3>
<p>https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html#suspicious-auto-trait-impls</p>
<p>This defends against some patterns that can lead to soundness issues. These cases currently can only trigger in patterns which are otherwise blocked by the <code>unsafe_code</code> lint, but for better defense-in-depth, it's explicitly forbidden in PL/Rust.</p>
<h3 id="soft_unstable"><a class="header" href="#soft_unstable"><code>soft_unstable</code></a></h3>
<p>https://doc.rust-lang.org/rustc/lints/listing/deny-by-default.html#soft-unstable</p>
<p>This prevents the use of language and library features which were accidentally stabilized. This is forbidden because there's no reason to need to use these, and forbidding them reduces the set of APIs and features we have to consider in PL/Rust.</p>
<h3 id="where_clauses_object_safety"><a class="header" href="#where_clauses_object_safety"><code>where_clauses_object_safety</code></a></h3>
<p>https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html#where-clauses-object-safety</p>
<p>This avoids some soundness holes that are in the language which can be used to trigger various crashes, see the lint documentation for details.</p>
<h2 id="plrust-plrustc-lints"><a class="header" href="#plrust-plrustc-lints">PL/Rust <code>plrustc</code> Lints</a></h2>
<h3 id="plrust_extern_blocks"><a class="header" href="#plrust_extern_blocks"><code>plrust_extern_blocks</code></a></h3>
<p>This blocks the declaration of <code>extern "API" {}"</code> blocks.  Primarily, this is to ensure a plrust function cannot
declare internal Postgres symbols as external.</p>
<p>For example, this code pattern is blocked:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern "C" {
    pub fn palloc(size: Size) -&gt; *mut ::std::os::raw::c_void;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="plrust_lifetime_parameterized_traits"><a class="header" href="#plrust_lifetime_parameterized_traits"><code>plrust_lifetime_parameterized_traits</code></a></h3>
<p>Traits parameterized by lifetimes can be used to exploit Rust compiler bugs that lead to unsoundness issues.  PL/Rust
does not allow such traits to be declared.</p>
<p>For example, this code pattern is blocked:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    trait Foo&lt;'a&gt; {}
<span class="boring">}</span></code></pre></pre>
<h3 id="plrust_filesystem_macros"><a class="header" href="#plrust_filesystem_macros"><code>plrust_filesystem_macros</code></a></h3>
<p>Filesystem macros such as <code>include_bytes!</code> and <code>include_str!</code> are disallowed, as they provide access to the underlying filesystem which should be unavailable to a trusted language handler.</p>
<p>For example, this code pattern is blocked:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const SOMETHING: &amp;str = include_str!("/etc/passwd");
<span class="boring">}</span></code></pre></pre>
<h3 id="plrust_fn_pointers"><a class="header" href="#plrust_fn_pointers"><code>plrust_fn_pointers</code></a></h3>
<p>Currently, several soundness holes have to do with the interaction between function pointers, implied bounds, and nested references. As a stopgap against these, use of function pointer types and function trait objects are currently blocked. This lint will likely be made more precise in the future.</p>
<p>Note that function types (such as the types resulting from closures as required by iterator functions) are still allowed, as these do not have the issues around variance.</p>
<p>For example, the following code pattern is blocked:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn takes_fn_arg(x: fn()) {
    x();
}
<span class="boring">}</span></code></pre></pre>
<h3 id="plrust_async"><a class="header" href="#plrust_async"><code>plrust_async</code></a></h3>
<p>Currently async/await are forbidden by PL/Rust due to unclear interactions around lifetime and soundness constraints. This may be out of an overabundance of caution. Specifically, code like the following will fail to compile:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn an_async_fn() {
    // ...
}

fn normal_function() {
    let async_block = async {
        // ...
    };
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="plrust_leaky"><a class="header" href="#plrust_leaky"><code>plrust_leaky</code></a></h3>
<p>This lint forbids use of "leaky" functions such as <a href="https://doc.rust-lang.org/stable/std/mem/fn.forget.html"><code>mem::forget</code></a> and <a href="https://doc.rust-lang.org/stable/std/boxed/struct.Box.html#method.leak"><code>Box::leak</code></a>. While leaking memory is considered safe, it has undesirable effects and thus is blocked by default. For example, the lint will trigger on (at least) the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>core::mem::forget(something);
let foo = Box::leak(Box::new(1u32));
let bar = vec![1, 2, 3].leak();
<span class="boring">}</span></code></pre></pre>
<p>Note that this will not prevent all leaks, as PL/Rust code could still create a leak by constructing a reference cycle using Rc/Arc, for example.</p>
<h3 id="plrust_env_macros"><a class="header" href="#plrust_env_macros"><code>plrust_env_macros</code></a></h3>
<p>This lint forbids use of environment macros such as <a href="https://doc.rust-lang.org/nightly/std/macro.env.html"><code>env!</code></a> and <a href="https://doc.rust-lang.org/nightly/std/macro.option_env.html"><code>option_env!</code></a>, as it allows access to data that should not be available to a trusted language handler.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let path = env!("PATH");
let rustup_toolchain_dir = option_env!("RUSTUP_TOOLCHAIN");
// ...
<span class="boring">}</span></code></pre></pre>
<h3 id="plrust_external_mod"><a class="header" href="#plrust_external_mod"><code>plrust_external_mod</code></a></h3>
<p>This lint forbids use of non-inline <code>mod blah</code>, as it can be used to access files a trusted language handler should not give access to.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is allowed
mod foo {
    // some functions or whatever here...
}

// This is disallowed.
mod bar;
// More importantly, this is disallowed as well.
#[path = "/sneaky/path/to/something"]
mod baz;
<span class="boring">}</span></code></pre></pre>
<h3 id="plrust_print_macros"><a class="header" href="#plrust_print_macros"><code>plrust_print_macros</code></a></h3>
<p>This lint forbids use of the <code>println!</code>/<code>eprintln!</code> family of macros (including <code>dbg!</code> and the non-<code>ln</code> variants), as these allow bypassing the norm. Users should use <code>pgrx::log!</code> or <code>pgrx::debug!</code> instead.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("hello");
print!("plrust");

eprintln!("this is also blocked");
eprint!("even without the newline");

dbg!("same here");
<span class="boring">}</span></code></pre></pre>
<h3 id="plrust_stdio"><a class="header" href="#plrust_stdio"><code>plrust_stdio</code></a></h3>
<p>This lint forbids use of the functions for accessing standard streams (stdin, stdout, stderr) from PL/Rust, for the same reason as above. For example, the following code is forbidden:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>std::io::stdout().write_all(b"foobar").unwrap();
std::io::stderr().write_all(b"foobar").unwrap();
let _stdin_is_forbidden_too = std::io::stdin();
<span class="boring">}</span></code></pre></pre>
<h3 id="plrust_static_impls"><a class="header" href="#plrust_static_impls"><code>plrust_static_impls</code></a></h3>
<p>This lint forbids certain <code>impl</code> blocks for types containing <code>&amp;'static</code> references. The precise details are somewhat obscure, but can usually be avoided by making a custom struct to contain your static reference, which avoids the particular soundness hole we're concerned with. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is forbidden:
impl SomeTrait for (&amp;'static Foo, Bar) {
    // ...
}

// Instead, do this:
struct MyType(&amp;'static Foo, Bar);
impl SomeTrait for MyType {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="plrust_autotrait_impls"><a class="header" href="#plrust_autotrait_impls"><code>plrust_autotrait_impls</code></a></h3>
<p>This lint forbids explicit implementations of the safe auto traits, as a workaround for various soundness holes around these. It may be relaxed in the future if those are fixed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo(std::cell::Cell&lt;i32&gt;, std::marker::PhantomPinned);
// Any of the following implementations would be forbidden.
impl std::panic::UnwindSafe for Foo {}
impl std::panic::RefUnwindSafe for Foo {}
impl std::marker::Unpin for Foo {}
<span class="boring">}</span></code></pre></pre>
<p>As a workaround, in most cases, you should be able to use <a href="https://doc.rust-lang.org/nightly/std/panic/struct.AssertUnwindSafe.html"><code>std::panic::AssertUnwindSafe</code></a> instead of implementing one of the <code>UnwindSafe</code> traits, and Boxing your type can usually work around the need for <code>Unpin</code> (which should be rare in non-<code>async</code> code anyway).</p>
<h3 id="plrust_suspicious_trait_object"><a class="header" href="#plrust_suspicious_trait_object"><code>plrust_suspicious_trait_object</code></a></h3>
<p>This lint forbids trait object use in turbofish and generic defaults. This is an effort to fix <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=764d78856996e1985ee88819b013c645">certain soundness holes</a> in the Rust language. More simply, the following patterns are disallowed:</p>
<pre><code class="language-rs">// Trait object in turbofish
foo::&lt;dyn SomeTrait&gt;();
// Trait object in type default (enum, union, trait, and so on are all also forbidden)
struct SomeStruct&lt;T = dyn SomeTrait&gt;(...);
</code></pre>
<h3 id="plrust_closure_trait_impl"><a class="header" href="#plrust_closure_trait_impl"><code>plrust_closure_trait_impl</code></a></h3>
<p>This lint forbids trait impls over generic over <code>Fn</code>, <code>FnOnce</code>, <code>FnMut</code> or
<code>FnPtr</code> types. This is to work around some soundness issues where closure types
are incorrectly <code>'static</code>. For example, the following is forbidden:</p>
<pre><code class="language-rs">trait Trait {}
// This is generic over a function trait.
impl&lt;F: Fn()&gt; Trait for F {}
</code></pre>
<p>However, this is currently overly strict. In the future, it may be relaxed to
forbid only the case where the return type is projected into an associated item
on the trait, as in:</p>
<pre><code class="language-rs">trait Trait {
    type Assoc;
}
impl&lt;R, F: Fn() -&gt; R&gt; Trait for F {
    // This is the problem
    type Assoc = R;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-variables"><a class="header" href="#environment-variables">Environment variables</a></h1>
<p>As part of PL/Rust's function compilation machinery, and in conjunction with <code>pgrx</code> which does the hard work, a number
of environment variables are set when PL/Rust executes <code>cargo</code>.</p>
<p>These are not environment variables that need to set manually.  Generally, these are auto-detected and cannot be
overridden through configuration.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Value</th><th>How it's Used</th></tr></thead><tbody>
<tr><td>PATH</td><td><code>~/cargo/bin:/usr/bin</code> or <code>/usr/bin</code> if "postgres" user has no home directory</td><td>The <code>PATH</code> environment variable is <strong>only</strong> set by PL/Rust if it detects that one isn't already set.  <br/>As mentioned above, this one <em>can</em> be overridden via the <code>plrust.PATH_override</code> GUC in <code>postgresql.conf</code>.</td></tr>
<tr><td>RUSTC</td><td><code>plrustc</code></td><td>This is set to plrust's "rust driver" executable, named <code>plrustc</code>.  It must be on the system PATH.</td></tr>
<tr><td>RUSTFLAGS</td><td><code>"-Clink-args=-Wl,-undefined,dynamic_lookup"</code></td><td>Used by <code>rustc</code> to indicate that Postgres internal symbols are only available at run-time, not compile-time.</td></tr>
<tr><td>CARGO_TARGET_DIR</td><td>value of GUC <code>plrust.work_dir</code>/<code>target</code></td><td>This is the filesystem path <code>cargo</code> will store its intermediate compilation artifacts.</td></tr>
<tr><td>CARGO_TARGET_X86_64_LINKER</td><td><code>x86_64-linux-gnu-gcc</code></td><td>Used only when cross-compiling <em>to</em> x86_64, this tells <code>rustc</code> which linker to use.  The <code>plrust.x86_64_linker</code> GUC can override the default.</td></tr>
<tr><td>CARGO_TARGET_AARCH64_LINKER</td><td><code>aarch64-linux-gnu-gcc</code></td><td>Used only when cross-compiling <em>to</em> aarch64, this tells <code>rustc</code> which linker to use.  The <code>plrust.aarch64_linker</code> GUC can override the default.</td></tr>
<tr><td>PGRX_TARGET_INFO_PATH_PG${MAJOR_VERSION_NUM}</td><td>unset unless <code>plrust.{x86_64/aarch64}_pgrx_bindings_path</code> GUC is set</td><td>Used only when cross-compiling <em>to</em> the specified target.  This tells <code>pgrx</code> where to find the generated Postgres bindings for that platform.</td></tr>
<tr><td>PGRX_PG_CONFIG_AS_EN_VAR</td><td><code>true</code></td><td>Indicates to the <code>trusted-pgrx</code> dependency, and ultimately <code>pgrx</code> itself that instead of getting the values it needs for compilation from the Postgres <code>pg_config</code> tool, it should get them from environment variables.</td></tr>
<tr><td>PGRX_PG_CONFIG_VERSION</td><td>Provided by the running Postgres instance</td><td>Used by <code>pgrx</code> to build the PL/Rust user function.</td></tr>
<tr><td>PGRX_PG_CONFIG_CPPFLAGS</td><td>Provided by the running Postgres instance</td><td>Used by <code>pgrx</code> to build the PL/Rust user function (technically unused by PL/Rust's build process as PL/Rust does not include the pgrx "cshim" for which this is normally used).</td></tr>
<tr><td>PGRX_PG_CONFIG_INCLUDEDIR-SERVER</td><td>Provided by the running Postgres instance</td><td>Used by <code>pgrx</code> to build the PL/Rust user function.</td></tr>
</tbody></table>
</div>
<h2 id="safety"><a class="header" href="#safety">Safety</a></h2>
<p>Note that PL/Rust uses Rust's <a href="https://doc.rust-lang.org/beta/std/process/struct.Command.html"><code>std::process::Command</code></a>
to exec <code>cargo</code>.  As such, it <strong>will</strong> inherit <strong>all</strong> environment variables set under the active backend <code>postgres</code>
process.  We recommend Postgres' execution environment be properly sanitized to your organizations requirements.</p>
<p>As a pre-emptive measure, PL/Rust proactively un-sets a few environment variables
that could negatively impact user function compilation.
These are generally things used by the <code>pgrx</code> development team that are not
necessary for PL/Rust.</p>
<ul>
<li><code>DOCS_RS</code></li>
<li><code>PGRX_BUILD_VERBOSE</code></li>
<li><code>PGRX_PG_SYS_GENERATE_BINDINGS_FOR_RELEASE</code></li>
<li><code>CARGO_MANIFEST_DIR</code></li>
<li><code>OUT_DIR</code></li>
</ul>
<h2 id="reserved-environment-variables"><a class="header" href="#reserved-environment-variables">Reserved environment variables</a></h2>
<p>There are a number of other <code>pg_config</code>-related environment variables that plrust sets.  These are not currently used,
but are reserved for future use, should they become necessary to build a user function:</p>
<ul>
<li><code>PGRX_PG_CONFIG_BINDIR</code></li>
<li><code>PGRX_PG_CONFIG_DOCDIR</code></li>
<li><code>PGRX_PG_CONFIG_HTMLDIR</code></li>
<li><code>PGRX_PG_CONFIG_INCLUDEDIR</code></li>
<li><code>PGRX_PG_CONFIG_PKGINCLUDEDIR</code></li>
<li><code>PGRX_PG_CONFIG_INCLUDEDIR-SERVER</code></li>
<li><code>PGRX_PG_CONFIG_LIBDIR</code></li>
<li><code>PGRX_PG_CONFIG_PKGLIBDIR</code></li>
<li><code>PGRX_PG_CONFIG_LOCALEDIR</code></li>
<li><code>PGRX_PG_CONFIG_MANDIR</code></li>
<li><code>PGRX_PG_CONFIG_SHAREDIR</code></li>
<li><code>PGRX_PG_CONFIG_SYSCONFDIR</code></li>
<li><code>PGRX_PG_CONFIG_PGRXS</code></li>
<li><code>PGRX_PG_CONFIG_CONFIGURE</code></li>
<li><code>PGRX_PG_CONFIG_CC</code></li>
<li><code>PGRX_PG_CONFIG_CPPFLAGS</code></li>
<li><code>PGRX_PG_CONFIG_CFLAGS</code></li>
<li><code>PGRX_PG_CONFIG_CFLAGS_SL</code></li>
<li><code>PGRX_PG_CONFIG_LDFLAGS</code></li>
<li><code>PGRX_PG_CONFIG_LDFLAGS_EX</code></li>
<li><code>PGRX_PG_CONFIG_LDFLAGS_SL</code></li>
<li><code>PGRX_PG_CONFIG_LIBS</code></li>
<li><code>PGRX_PG_CONFIG_VERSION</code></li>
</ul>
<h2 id="influencing-plrust-compilation"><a class="header" href="#influencing-plrust-compilation">Influencing PL/Rust Compilation</a></h2>
<p>If set, PL/Rust will use the <code>PLRUST_TRUSTED_PGRX_OVERRIDE</code> environment variable when PL/Rust itself is being compiled.
See the <a href="install-plrust.html">Choosing a different <code>plrust-trusted-pgrx</code> dependency at compile time</a> section for details.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
